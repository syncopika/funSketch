{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./built/SuperCanvas.js","webpack:///./index.js","webpack:///./built/Brush.js","webpack:///./built/Toolbar.js","webpack:///./built/Filters.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Frame","container","number","this","width","height","currentIndex","canvasList","currentCanvas","tainted","count","getMetadata","getCurrCanvas","setupNewLayer","newCanvas","document","createElement","id","setCanvas","style","opacity","zIndex","getElementById","appendChild","canvas","top","offsetTop","left","offsetLeft","push","hide","forEach","visibility","show","copyCanvas","getContext","drawImage","clearCurrentLayer","currLayer","context","clearRect","getAttribute","fillStyle","fillRect","resetFrame","canvasElement","position","border","setAttribute","addEventListener","$","css","project","currentFrame","speed","frameList","onionSkinFrame","createOnionSkinFrame","display","resetProject","frame","frameIndex","parent","layer","layerIndex","removeChild","addNewFrame","showFlag","newFrame","length","nextFrame","prevFrame","getCurrFrame","updateOnionSkin","onionSkinCtx","onionSkinImageData","getImageData","imageData","data","putImageData","newBrush","animationProject","previousCanvas","undefined","currentCanvasSnapshots","selectedBrush","currColor","currColorArray","Uint8Array","from","currSize","tempSnapshot","clickX","clickY","clickDrag","clickColor","clickSize","thisBrushInstance","radialGrad","x","y","radGrad","createRadialGradient","colorPicked","addColorStop","resetBrush","curCanvas","off","addClick","dragging","redraw","lineJoin","beginPath","moveTo","lineTo","closePath","strokeStyle","lineWidth","stroke","changeBrushSize","size","defaultBrush","paint","on","e","which","type","rect","target","getBoundingClientRect","offsetX","originalEvent","touches","pageX","offsetY","pageY","preventDefault","w","h","mouseleave","radialGradBrush","lineCap","mousedown","mousemove","mouseup","newToolbar","brush","animationProj","recentImage","play","timePerFrame","layerMode","htmlCounter","setCounter","elementId","up","down","curr","next","prev","addPage","setKeyDown","doc","toolbar","counterText","keydown","counterUpdateString","textContent","insertLayer","click","newestCanvas","pop","splice","deleteLayer","toolbarReference","oldCanvasIndex","oldCanvasId","parentNode","addNewFrameButton","createColorWheel","location","colorWheel","colorWheelContext","angle","startAngle","Math","PI","endAngle","arc","gradient","fill","showColor","textAlign","colorPickedText","floodFill","doFloodFill","substring","indexOf","split","map","a","parseInt","offset","colorData","color","console","log","pixel","floor","newColor","pixelSelected","stack","visited","targetColor","ctx","currPixel","g","b","leftNeighborX","rightNeighborX","topNeighborY","bottomNeighborY","floodfill","removeEventListener","rotateImage","Promise","all","createImageBitmap","then","bitmap","translate","rotate","setClearCanvas","undo","unshift","mostRecentImage","importImage","input","getFile","img","Image","reader","FileReader","file","files","match","onload","onloadend","src","result","readAsDataURL","resetImage","download","toBlob","blob","url","URL","createObjectURL","link","href","prompt","playFor","playBack","playForward","clearInterval","setInterval","playBackward","stop","getGif","gif","GIF","workers","quality","tempCanvas","tempCtx","tempImageData","currFrame","j","k","addFrame","delay","newGif","window","open","render","save","savedData","newLayer","toDataURL","layers","JSON","stringify","json","join","Blob","importProject","counterId","self","parse","index","currFrameLayersFromImport","currFrameLayersFromCurrPrj","image","readAsText","element","tempImage","makePath","col","row","fisheye","imgData","xPos","yPos","rad","sqrt","oldData","Uint8ClampedArray","pixelCounter","normY","normY2","start","normX","normX2","dist","newR","theta","atan2","newX","cos","newY","sin","x2","y2","srcPos","withinRange","or","og","ob","rangeVal","red","abs","green","blue","Point","Node","point","dim","right","getPixelCoords","pixelNum","yCoord","getDist","x1","y1","pow","findNearestNeighbor","root","record","nearestNeighbor","minDist","findNearestNeighborHelper","node","currDist","filterCanvas","filter","filterCanvasOption","option","grayscale","pixels","sepia","saturate","g2","swap","banded","purpleChrome","purplizer","scary","heatwave","randomize","rand","random","invert","blurry","maximum","cond1","cond2","cond3","cond4","newG","newB","newA","outline","colCounter","rowCounter","tnr","tng","tnb","defaultFisheye","areaColor","copy","lnr","lng","lnb","rnr","rng","rnb","bnr","bng","bnb","trr","trg","trb","tlr","tlg","tlb","blr","blg","blb","brr","brg","brb","cond5","cond6","cond7","cond8","nnr","nng","nnb","trrr","trrg","trrb","mosaic","chunkWidth","chunkHeight","pixelate","voronoi","neighborList","sign","c1","p1","kdtree","build2dTree","pointsList","currDim","sort","newParent","newChild","midIndex","newNode","slice","currCoords","edgeDetect","sourceImageCopy","xKernel","yKernel","bottom","topLeft","topRight","bottomLeft","bottomRight","center","pX","pY","newVal","ceil","showOptions","category","el","child","children","marginBottom"],"mappings":"aACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QAKfF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,IAIjBlC,EAAoBA,EAAoBmC,EAAI,G,+BCnErD,SAASC,EAAMC,EAAWC,GACtBC,KAAKC,MAAQ,IACbD,KAAKE,OAAS,IACdF,KAAKG,aAAe,EACpBH,KAAKI,WAAa,GAClBJ,KAAKK,cACLL,KAAKF,UAAYA,EACjBE,KAAKM,SAAU,EACfN,KAAKD,OAASA,EACdC,KAAKO,MAAQ,EACbP,KAAKQ,YAAc,WACf,MAAO,CACH,MAASR,KAAKC,MACd,OAAUD,KAAKE,OACf,aAAgBF,KAAKG,aACrB,OAAUH,KAAKD,SAGvBC,KAAKS,cAAgB,WACjB,OAAOT,KAAKI,WAAWJ,KAAKG,eAMhCH,KAAKU,cAAgB,WAEjB,IAAIC,EAAYC,SAASC,cAAc,UAcvC,GAbAF,EAAUG,GAAK,QAAUd,KAAKD,OAAS,SAAWC,KAAKO,MACvDQ,EAAUJ,EAAWX,KAAKC,MAAOD,KAAKE,QACnB,IAAfF,KAAKO,QACLI,EAAUK,MAAMC,QAAU,IAC1BN,EAAUK,MAAME,OAAS,GAG7BN,SAASO,eAAenB,KAAKF,WAAWsB,YAAYT,GAEjC,IAAfX,KAAKO,QACLP,KAAKK,cAAgBM,GAGrBX,KAAKO,OAAS,EAAG,CAEjB,IAAIc,EAAST,SAASO,eAAenB,KAAKI,WAAW,GAAGU,IACpDQ,EAAMD,EAAOE,UACbC,EAAOH,EAAOI,WAClBd,EAAUK,MAAMM,IAAMA,EACtBX,EAAUK,MAAMQ,KAAOA,EAE3BxB,KAAKI,WAAWsB,KAAKf,GACrBX,KAAKO,SAETP,KAAK2B,KAAO,WAER3B,KAAKI,WAAWwB,SAAQ,SAAUP,GAC9BA,EAAOL,MAAME,QAAU,EACvBG,EAAOL,MAAMa,WAAa,aAGlC7B,KAAK8B,KAAO,WAER9B,KAAKI,WAAWwB,SAAQ,SAAUP,GAC9BA,EAAOL,MAAME,OAAS,EACtBG,EAAOL,MAAMa,WAAa,OAMlC7B,KAAK+B,WAAa,WACd,IAAIpB,EAAYC,SAASC,cAAc,UACvCF,EAAUG,GAAK,QAAUd,KAAKD,OAAS,SAAWC,KAAKO,MACvDQ,EAAUJ,EAAWX,KAAKC,MAAOD,KAAKE,QACtCF,KAAKI,WAAWJ,KAAKO,MAAQ,GAAGS,MAAMC,QAAU,IAEhDL,SAASO,eAAerB,GAAWsB,YAAYT,GAE/C,IAAIU,EAAST,SAASO,eAAenB,KAAKI,WAAW,GAAGU,IACpDQ,EAAMD,EAAOE,UACbC,EAAOH,EAAOI,WAClBd,EAAUK,MAAMM,IAAMA,EACtBX,EAAUK,MAAMQ,KAAOA,EACvBb,EAAUqB,WAAW,MAAMC,UAAUjC,KAAKK,cAAe,EAAG,GAC5DL,KAAKI,WAAWsB,KAAKf,GACrBX,KAAKO,SAETP,KAAKkC,kBAAoB,WACrB,IAAIC,EAAYnC,KAAKS,gBACjB2B,EAAUD,EAAUH,WAAW,MACnCI,EAAQC,UAAU,EAAG,EAAGF,EAAUG,aAAa,SAAUH,EAAUG,aAAa,WAChFF,EAAQG,UAAY,UACpBH,EAAQI,SAAS,EAAG,EAAGL,EAAUG,aAAa,SAAUH,EAAUG,aAAa,YAEnFtC,KAAKyC,WAAa,aAkHtB,SAAS1B,EAAU2B,EAAezC,EAAOC,GACrCwC,EAAc1B,MAAM2B,SAAW,WAC/BD,EAAc1B,MAAM4B,OAAS,iBAC7BF,EAAc1B,MAAME,OAAS,EAC7BwB,EAAc1B,MAAMC,QAAU,EAC9ByB,EAAcG,aAAa,QAAS5C,GACpCyC,EAAcG,aAAa,SAAU3C,GACrCwC,EAAcV,WAAW,MAAMO,UAAY,wBAC3CG,EAAcV,WAAW,MAAMQ,SAAS,EAAG,EAAGvC,EAAOC,G,OChOzDU,SAASkC,iBAAiB,oBAAoB,WAC7CC,EAAE,QAAQC,IAAI,UAAW,YAI1B,IAAIC,EAAU,IDwGd,SAA0BnD,GACtBE,KAAK5B,KAAO,GACZ4B,KAAKkD,aAAe,EACpBlD,KAAKmD,MAAQ,IACbnD,KAAKoD,UAAY,GACjBpD,KAAKhB,KAAO,EACZgB,KAAKqD,eAuFT,SAA8BvD,GAC1B,IAGIa,EAAYC,SAASC,cAAc,UAOvC,OANAF,EAAUG,GAAK,kBACfC,EAAUJ,EALE,IACC,KAKbA,EAAUK,MAAMC,QAAU,IAC1BN,EAAUK,MAAME,QAAU,EAE1BN,SAASO,eAAerB,GAAWsB,YAAYT,GACxCA,EAlGe2C,CAAqBxD,GAC3CE,KAAKqD,eAAerC,MAAMuC,QAAU,OACpCvD,KAAKF,UAAYA,EACjBE,KAAKwD,aAAe,WAChBxD,KAAKoD,UAAUxB,SAAQ,SAAU6B,EAAOC,GAEpC,IAAIC,EAAS/C,SAASO,eAAesC,EAAK,WAE1CA,EAAMrD,WAAWwB,SAAQ,SAAUgC,EAAOC,GAClCA,EAAa,GACbF,EAAOG,YAAYF,MAG3BH,EAAMrD,WAAa,CAACqD,EAAMrD,WAAW,IAClB,IAAfsD,IACAD,EAAMtD,aAAe,EACrBsD,EAAMpD,cAAgBoD,EAAMrD,WAAW,OAG/CJ,KAAKoD,UAAY,CAACpD,KAAKoD,UAAU,IAEjCpD,KAAKoD,UAAU,GAAGlB,oBAClBlC,KAAKkD,aAAe,EACpBlD,KAAKhB,KAAO,EACZgB,KAAKmD,MAAQ,KAEjBnD,KAAK+D,YAAc,SAAUC,GACzB,IAAIC,EAAW,IAAIpE,EAAMG,KAAKF,UAAWE,KAAKoD,UAAUc,QACxDD,EAASvD,gBACTV,KAAKoD,UAAU1B,KAAKuC,GACfD,GACDC,EAAStC,QAGjB3B,KAAKmE,UAAY,WACb,OAAInE,KAAKoD,UAAUc,SAAWlE,KAAKkD,aAAe,EACvC,MAEXlD,KAAKkD,cAAgB,EACdlD,KAAKoD,UAAUpD,KAAKkD,gBAE/BlD,KAAKoE,UAAY,WACb,OAAIpE,KAAKkD,aAAe,EAAI,EACjB,MAEXlD,KAAKkD,cAAgB,EACdlD,KAAKoD,UAAUpD,KAAKkD,gBAE/BlD,KAAKqE,aAAe,WAChB,OAAOrE,KAAKoD,UAAUpD,KAAKkD,eAE/BlD,KAAKsE,gBAAkB,WACnB,KAAItE,KAAKkD,aAAe,EAAI,GAA5B,CAIAlD,KAAKqD,eAAerC,MAAMuC,QAAU,GACpC,IAAIgB,EAAevE,KAAKqD,eAAerB,WAAW,MAClDuC,EAAalC,UAAU,EAAG,EAAGrC,KAAKqD,eAAepD,MAAOD,KAAKqD,eAAenD,QAG5E,IAAIsE,EAAqBD,EAAaE,aAAa,EAAG,EAAGzE,KAAKqD,eAAepD,MAAOD,KAAKqD,eAAenD,QAExFF,KAAKoD,UAAUpD,KAAKkD,aAAe,GACzC9C,WAAWwB,SAAQ,SAAUgC,GAEnC,IADA,IAAIc,EAAYd,EAAM5B,WAAW,MAAMyC,aAAa,EAAG,EAAGb,EAAM3D,MAAO2D,EAAM1D,QAAQyE,KAC5E9G,EAAI,EAAGA,EAAI6G,EAAUR,OAAQrG,GAAK,EAClB,MAAjB6G,EAAU7G,IAAmC,MAArB6G,EAAU7G,EAAI,IAAmC,MAArB6G,EAAU7G,EAAI,KAMlE2G,EAAmBG,KAAK9G,GAAK6G,EAAU7G,GACvC2G,EAAmBG,KAAK9G,EAAI,GAAK6G,EAAU7G,EAAI,GAC/C2G,EAAmBG,KAAK9G,EAAI,GAAK6G,EAAU7G,EAAI,GAC/C2G,EAAmBG,KAAK9G,EAAI,GAAK,KAIzC0G,EAAaK,aAAaJ,EAAoB,EAAG,MAErDxE,KAAKqD,eAAerC,MAAME,OAAS,EACnClB,KAAKqD,eAAerC,MAAMC,QAAU,MCjM9B,CAAqB,cACnCgC,EAAQc,aAAY,GACpB,IAAIpD,EAAYsC,EAAQoB,eAGpBQ,EAAW,ICVf,SAAeC,GAEX9E,KAAK+E,oBAAiBC,EACtBhF,KAAKiF,uBAAyB,GAC9BjF,KAAKkF,cAAgB,UACrBlF,KAAKmF,UAAY,OACjBnF,KAAKoF,eAAiBC,WAAWC,KAAK,CAAC,EAAG,EAAG,EAAG,IAChDtF,KAAKuF,SAAW,EAGhB,IAOIC,EAPAC,EAAS,GACTC,EAAS,GACTC,EAAY,GACZC,EAAa,GACbC,EAAY,GAUZC,EAAoB9F,KAwGxB,SAAS+F,EAAWC,EAAGC,GACnB,IACI7D,EADS0C,EAAiBT,eACThE,cAAc2B,WAAW,MAC1CkE,EAAU9D,EAAQ+D,qBAAqBH,EAAGC,EAAGH,EAAkBP,SAAUS,EAAGC,EAAgC,IAA7BH,EAAkBP,UACjGa,EAAcN,EAAkBV,eACpCc,EAAQG,aAAa,EAAGP,EAAkBX,gBACtBH,IAAhBoB,GACAF,EAAQG,aAAa,GAAI,QAAUD,EAAY,GAAK,IAAMA,EAAY,GAAK,IAAMA,EAAY,GAAK,QAClGF,EAAQG,aAAa,EAAG,QAAUD,EAAY,GAAK,IAAMA,EAAY,GAAK,IAAMA,EAAY,GAAK,SAGjGF,EAAQG,aAAa,GAAI,kBACzBH,EAAQG,aAAa,EAAG,kBAE5BjE,EAAQG,UAAY2D,EACpB9D,EAAQI,SAASwD,EAAI,GAAIC,EAAI,GAAI,GAAI,IAEzC,SAASK,IACL,IACIC,EADSzB,EAAiBT,eACP5D,gBAAgBK,GAEvCiC,EAAE,IAAMwD,GAAWC,IAAI,aACvBzD,EAAE,IAAMwD,GAAWC,IAAI,WACvBzD,EAAE,IAAMwD,GAAWC,IAAI,aAG3B,SAASC,EAAST,EAAGC,EAAGS,GAEpBjB,EAAO/D,KAAKsE,GACZN,EAAOhE,KAAKuE,GACZN,EAAUjE,KAAKgF,GACfd,EAAWlE,KAAKoE,EAAkBX,WAClCU,EAAUnE,KAAKoE,EAAkBP,UAErC,SAASoB,EAAOtF,GACZ,IACIe,EADS0C,EAAiBT,eACThE,cAAc2B,WAAW,MAC9CI,EAAQwE,SAAW,QACnB,IAAK,IAAI/I,EAAI,EAAGA,EAAI4H,EAAOvB,OAAQrG,IAC/BuE,EAAQyE,YAIJlB,EAAU9H,IAAMA,EAChBuE,EAAQ0E,OAAOrB,EAAO5H,EAAI,GAAI6H,EAAO7H,EAAI,IAIzCuE,EAAQ0E,OAAOrB,EAAO5H,GAAI6H,EAAO7H,GAAK,GAE1CuE,EAAQ2E,OAAOtB,EAAO5H,GAAI6H,EAAO7H,IACjCuE,EAAQ4E,YACR5E,EAAQ6E,YAAcrB,EAAW/H,GACjCuE,EAAQ8E,UAAYrB,EAAUhI,GAC9BuE,EAAQ+E,SA7JhBnH,KAAKoH,gBAAkB,SAAUC,GAC7BrH,KAAKuF,SAAW8B,GAEpBrH,KAAKsH,aAAe,WAEhBhB,IACA,IACIiB,EADAlG,EAASyD,EAAiBT,eAE9BtB,EAAE,IAAM1B,EAAOhB,cAAcS,IAAI0G,GAAG,wBAAwB,SAAUC,GAClE,GAAiB,IAAZA,EAAEC,OAA0B,cAAXD,EAAEE,MAAoC,eAAXF,EAAEE,KAAuB,CAgBtE,GAdI7B,EAAkBf,iBAAmB1D,EAAOhB,gBAC5CyF,EAAkBf,eAAiB1D,EAAOhB,cAE1CyF,EAAkBb,uBAAyB,IAE3CO,GACAM,EAAkBb,uBAAuBvD,KAAK8D,GAElD+B,GAAQ,EAMO,eAAXE,EAAEE,KAAuB,CACzB,IAAIC,EAAOH,EAAEI,OAAOC,wBACpBL,EAAEM,QAAUN,EAAEO,cAAcC,QAAQ,GAAGC,MAAQN,EAAKpG,KACpDiG,EAAEU,QAAUV,EAAEO,cAAcC,QAAQ,GAAGG,MAAQR,EAAKtG,IAExDmF,EAASgB,EAAEM,QAASN,EAAEU,SAAS,GAC/BxB,EAAOtF,OAIf0B,EAAE,IAAM1B,EAAOhB,cAAcS,IAAI0G,GAAG,uBAAuB,SAAUC,GACjE,GAAIF,EAAO,CACP,GAAe,cAAXE,EAAEE,KAAsB,CACxB,IAAIC,EAAOH,EAAEI,OAAOC,wBACpBL,EAAEM,QAAUN,EAAEO,cAAcC,QAAQ,GAAGC,MAAQN,EAAKpG,KACpDiG,EAAEU,QAAUV,EAAEO,cAAcC,QAAQ,GAAGG,MAAQR,EAAKtG,IAEpDmG,EAAEY,iBAEN5B,EAASgB,EAAEM,QAASN,EAAEU,SAAS,GAC/BxB,EAAOtF,OAIf0B,EAAE,IAAM1B,EAAOhB,cAAcS,IAAI0G,GAAG,oBAAoB,SAAUC,GAE9D,GAAI3B,EAAkBf,iBAAmB1D,EAAOhB,cAAe,CAE3D,IAAInC,EAAImD,EAAOhB,cACXiI,EAAIpK,EAAE+B,MACNsI,EAAIrK,EAAEgC,OACVsF,EAAenE,EAAOhB,cAAc2B,WAAW,MAAMyC,aAAa,EAAG,EAAG6D,EAAGC,GAyGnF9C,EAAS,GACTC,EAAS,GACTC,EAAY,GACZC,EAAa,GACbC,EAAY,GA1GR0B,GAAQ,KAGZxE,EAAE,IAAM1B,EAAOhB,cAAcS,IAAI0H,YAAW,SAAUf,GAClDF,GAAQ,MAMhBvH,KAAKyI,gBAAkB,WAEnBnC,IACA,IAGIiB,EAHAlG,EAASyD,EAAiBT,eAC1BkC,EAAYlF,EAAOhB,cAAcS,GACjCsB,EAAUf,EAAOhB,cAAc2B,WAAW,MAE9CI,EAAQwE,SAAWxE,EAAQsG,QAAU,QACrC3F,EAAE,IAAMwD,GAAWoC,WAAU,SAAUlB,GACnB,IAAZA,EAAEC,QACFH,GAAQ,EACRxB,EAAW0B,EAAEM,QAASN,EAAEU,aAGhCpF,EAAE,IAAMwD,GAAWqC,WAAU,SAAUnB,GAC/BF,GACAxB,EAAW0B,EAAEM,QAASN,EAAEU,YAGhCpF,EAAE,IAAMwD,GAAWsC,SAAQ,SAAUpB,GAEjC,GADAF,GAAQ,EACJzB,EAAkBf,iBAAmB1D,EAAOhB,cAAe,CAE3D,IAAInC,EAAImD,EAAOhB,cACXiI,EAAIpK,EAAE+B,MACNsI,EAAIrK,EAAEgC,OACV4F,EAAkBb,uBAAuBvD,KAAKL,EAAOhB,cAAc2B,WAAW,MAAMyC,aAAa,EAAG,EAAG6D,EAAGC,QAIlHxF,EAAE,IAAMwD,GAAWiC,YAAW,SAAUf,GACpCF,GAAQ,MDnHL,CAAUtE,GACzB4B,EAASyC,eAIT,IAAIwB,EAAa,IElBjB,SAAiBzH,EAAQ0H,EAAOC,GAG5B,IAAIC,EAEAC,EAAO,KAKXlJ,KAAKmJ,aAAe,IAGpBnJ,KAAKoJ,WAAY,EACjBpJ,KAAKqJ,YAAc,GACnBrJ,KAAKsJ,WAAa,SAAUC,GACxBvJ,KAAKqJ,YAAczI,SAASO,eAAeoI,IAE/CvJ,KAAKwJ,GAAK,WAEN,IAAInI,EAAS2H,EAAc3E,eAC3B,OAAIhD,EAAOlB,aAAe,EAAIkB,EAAOjB,WAAW8D,SAE5C7C,EAAOhB,cAAcW,MAAMC,QAAU,IACrCI,EAAOhB,cAAcW,MAAME,OAAS,EAGhCG,EAAOlB,aAAe,IAEtBkB,EAAOjB,WAAWiB,EAAOlB,aAAe,GAAGa,MAAMC,QAAU,EAC3DI,EAAOjB,WAAWiB,EAAOlB,aAAe,GAAGa,MAAME,OAAS,GAG9DG,EAAOjB,WAAWiB,EAAOlB,aAAe,GAAGa,MAAMC,QAAU,IAC3DI,EAAOjB,WAAWiB,EAAOlB,aAAe,GAAGa,MAAME,OAAS,EAC1DG,EAAOhB,cAAgBgB,EAAOjB,WAAWiB,EAAOlB,aAAe,GAC/DkB,EAAOlB,eAEP4I,EAAMzB,gBACC,IAIftH,KAAKyJ,KAAO,WAER,IAAIpI,EAAS2H,EAAc3E,eAC3B,OAAIhD,EAAOlB,aAAe,GAAK,IAG3BkB,EAAOhB,cAAcW,MAAMC,QAAU,EACrCI,EAAOhB,cAAcW,MAAME,OAAS,EAEpCG,EAAOjB,WAAWiB,EAAOlB,aAAe,GAAGa,MAAMC,QAAU,IAC3DI,EAAOjB,WAAWiB,EAAOlB,aAAe,GAAGa,MAAME,OAAS,EAEtDG,EAAOlB,aAAe,GAAK,IAC3BkB,EAAOjB,WAAWiB,EAAOlB,aAAe,GAAGa,MAAMC,QAAU,KAE/DI,EAAOhB,cAAgBgB,EAAOjB,WAAWiB,EAAOlB,aAAe,GAC/DkB,EAAOlB,eAEP4I,EAAMzB,gBACC,IAIftH,KAAKmE,UAAY,WACb,IAAIuF,EAAOV,EAAc3E,eACrBsF,EAAOX,EAAc7E,YACzB,OAAa,OAATwF,IACAD,EAAK/H,OACLgI,EAAK7H,OACLkH,EAAc1E,kBACdyE,EAAMzB,gBACC,IAIftH,KAAKoE,UAAY,WACb,IAAIsF,EAAOV,EAAc3E,eACrBuF,EAAOZ,EAAc5E,YACzB,OAAa,OAATwF,IACAF,EAAK/H,OACLiI,EAAK9H,OACLkH,EAAc1E,kBACdyE,EAAMzB,gBACC,IAIftH,KAAK6J,QAAU,WAEEb,EAAc3E,eACpB3D,iBAEXV,KAAK8J,WAAa,SAAUC,GACxB,IAAIC,EAAUhK,KACViK,EAAcjK,KAAKqJ,YACvBtG,EAAEgH,GAAKG,SAAQ,SAAUzC,GACrB,IAAI0C,EAAsB,GAC1B,OAAQ1C,EAAEC,OACN,KAAK,GACD,GAAIsC,EAAQP,OAAQ,CAChB,IAAIpI,EAAS2H,EAAc3E,eAC3B8F,EAAsB,WAAanB,EAAc9F,aAAe,GAAK,aAAe7B,EAAOlB,aAAe,GAE9G,MACJ,KAAK,GACD,GAAI6J,EAAQR,KAAM,CACVnI,EAAS2H,EAAc3E,eAC3B8F,EAAsB,WAAanB,EAAc9F,aAAe,GAAK,aAAe7B,EAAOlB,aAAe,GAE9G,MACJ,KAAK,GACG6J,EAAQZ,UACRY,EAAQH,UAGRb,EAAcjF,cAElB,MACJ,KAAK,GACD,GAAIiG,EAAQ5F,YAAa,CACjB/C,EAAS2H,EAAc3E,eAC3B8F,EAAsB,WAAanB,EAAc9F,aAAe,GAAK,aAAe7B,EAAOlB,aAAe,GAE9G,MACJ,KAAK,GACD,GAAI6J,EAAQ7F,YAAa,CACjB9C,EAAS2H,EAAc3E,eAC3B8F,EAAsB,WAAanB,EAAc9F,aAAe,GAAK,aAAe7B,EAAOlB,aAAe,IAMlH6J,EAAQX,aAAec,IACvBF,EAAYG,YAAcD,GAE9B1C,EAAEY,qBAMVrI,KAAKqK,YAAc,SAAUd,GAGzBxG,EAAE,IAAMwG,GAAWe,OAAM,WACrB,IAAIjJ,EAAS2H,EAAc3E,eAE3BhD,EAAOX,gBAEP,IAAI6J,EAAelJ,EAAOjB,WAAWoK,MACrCnJ,EAAOjB,WAAWqK,OAAOpJ,EAAOlB,aAAe,EAAG,EAAGoK,OAS7DvK,KAAK0K,YAAc,SAAUnB,GAEzB,IAAIoB,EAAmB3K,KACvB+C,EAAE,IAAMwG,GAAWe,OAAM,WACrB,IAAIjJ,EAAS2H,EAAc3E,eACvBuG,EAAiBvJ,EAAOlB,aACxB0K,EAAcxJ,EAAOhB,cAAcS,GACnCgK,EAAalK,SAASO,eAAe0J,GAAaC,WAEtD,GAAIzJ,EAAOlB,aAAe,EAAIkB,EAAOjB,WAAW8D,OAE5CyG,EAAiBnB,KAEjBnI,EAAOjB,WAAWqK,OAAOG,EAAgB,GACzCE,EAAWhH,YAAYlD,SAASO,eAAe0J,IAE/CxJ,EAAOlB,cAAgB,OAEtB,GAAIkB,EAAOlB,aAAe,GAAK,EAKhCwK,EAAiBlB,OACjBpI,EAAOjB,WAAWqK,OAAOG,EAAgB,GACzCE,EAAWhH,YAAYlD,SAASO,eAAe0J,IAE3CF,EAAiBtB,cACjBsB,EAAiBtB,YAAYe,YAAc,WAAapB,EAAc9F,aAAe,GAAK,YAAc7B,EAAOlB,aAAe,QAGjI,CAED,IAAIiC,EAAUf,EAAOhB,cAAc2B,WAAW,MAC9CI,EAAQC,UAAU,EAAG,EAAGhB,EAAOhB,cAAciC,aAAa,SAAUjB,EAAOhB,cAAciC,aAAa,WACtGF,EAAQG,UAAY,OACpBH,EAAQI,SAAS,EAAG,EAAGnB,EAAOhB,cAAciC,aAAa,SAAUjB,EAAOhB,cAAciC,aAAa,gBAQjHtC,KAAK+K,kBAAoB,SAAUxB,GAC/BxG,EAAE,IAAMwG,GAAWe,OAAM,WACrBtB,EAAcjF,kBAQtB/D,KAAKgL,iBAAmB,SAAUzB,EAAWlC,GACzC,IAAI4D,EAAWrK,SAASO,eAAeoI,GACnC2B,EAAatK,SAASC,cAAc,UACxCqK,EAAWpK,GAAK,aAChBoK,EAAWrI,aAAa,QAASwE,GACjC6D,EAAWrI,aAAa,SAAUwE,GAMlC,IALA,IAAI8D,EAAoBD,EAAWlJ,WAAW,MAC1CgE,EAAIkF,EAAWjL,MAAQ,EACvBgG,EAAIiF,EAAWhL,OAAS,EAGnBkL,EAAQ,EAAGA,GAAS,KAAMA,IAAS,CACxC,IAAIC,GAAcD,EAAQ,GAAKE,KAAKC,GAAK,IACrCC,EAAYJ,EAASE,KAAKC,GAAK,IACnCJ,EAAkBtE,YAClBsE,EAAkBrE,OAAOd,EAAGC,GAE5BkF,EAAkBM,IAAIzF,EAAGC,EARhB,GAQ2BoF,EAAYG,GAAU,GAC1DL,EAAkBnE,YAGlB,IAAI0E,EAAWP,EAAkBhF,qBAAqBH,EAAGC,EAAG,EAAGoF,EAAYG,EAZlE,IAaTE,EAASrF,aAAa,EAAG,QAAU+E,EAAQ,mBAC3CM,EAASrF,aAAa,EAAG,QAAU+E,EAAQ,mBAC3CD,EAAkB5I,UAAYmJ,EAC9BP,EAAkBQ,OAGtBR,EAAkB5I,UAAY,OAC9B4I,EAAkB3I,SAAS,EAAG,EAAG,EAAG,GAEpC2I,EAAkB3I,SAAS,GAAI,EAAG,EAAG,GACrC2I,EAAkB5I,UAAY,OAC9B4I,EAAkB3I,SAAS,GAAI,EAAG,EAAG,GACrCyI,EAAS7J,YAAY8J,GAErB,IAAIU,EAAYhL,SAASC,cAAc,KACvC+K,EAAU5K,MAAM6K,UAAY,SAC5BD,EAAU9K,GAAK,cACf8K,EAAUxB,YAAc,mBACxBa,EAAS7J,YAAYwK,GACrB7I,EAAE,IAAMmI,EAAWpK,IAAI6H,WAAU,SAAUlB,GACvC,IAAIzB,EAAIyB,EAAEM,QACN9B,EAAIwB,EAAEU,QACN/B,EAAexF,SAASO,eAAe+J,EAAWpK,IAAIkB,WAAW,MAAOyC,aAAauB,EAAGC,EAAG,EAAG,GAAGtB,KACjGmH,EAAkBlL,SAASO,eAAeyK,EAAU9K,IAEpDsF,EAAY,GAAK,IAAMA,EAAY,GAAK,IACxCrD,EAAE,IAAM6I,EAAU9K,IAAIkC,IAAI,QAAS,QAGnCD,EAAE,IAAM6I,EAAU9K,IAAIkC,IAAI,QAAS,QAEvC8I,EAAgB1B,YAAc,OAAShE,EAAY,GAAK,IAAMA,EAAY,GAAK,IAAMA,EAAY,GAAK,IACtGrD,EAAE,IAAM6I,EAAU9K,IAAIkC,IAAI,CAAE,mBAAoB8I,EAAgB1B,cAEhErB,EAAM3D,eAAiBgB,EACvB2C,EAAM5D,UAAY,OAASiB,EAAY,GAAK,IAAMA,EAAY,GAAK,IAAMA,EAAY,GAAK,QAelGpG,KAAK+L,UAAY,SAAUxC,GACvBxG,EAAE,IAAMwG,GAAWe,OAAM,WACrB,IAAIjJ,EAAS2H,EAAc3E,eACvB2H,EAAc,SAAUvE,GAIxB,IAAItC,EAAY4D,EAAM5D,UAClBC,EAAiBD,EAAU8G,UAAU9G,EAAU+G,QAAQ,KAAO,EAAG/G,EAAUjB,OAAS,GAAGiI,MAAM,KACjG/G,EAAiBA,EAAegH,KAAI,SAAUC,GAAK,OAAOC,SAASD,MAEnE,IAAIrG,EAAIyB,EAAES,MAAQnF,EAAE,IAAM1B,EAAOhB,cAAcS,IAAIyL,SAAS/K,KACxDyE,EAAIwB,EAAEW,MAAQrF,EAAE,IAAM1B,EAAOhB,cAAcS,IAAIyL,SAASjL,IAExDkL,EAAY5L,SAASO,eAAeE,EAAOhB,cAAcS,IAAIkB,WAAW,MAAMyC,aAAauB,EAAGC,EAAG,EAAG,GAAGtB,KACvG8H,EAAQ,OAASD,EAAU,GAAK,IAAMA,EAAU,GAAK,IAAMA,EAAU,GAAK,IAC9EE,QAAQC,IAAIF,GAEZ,IAAIG,EAAQ,CAAE,EAAKtB,KAAKuB,MAAM7G,GAAI,EAAKsF,KAAKuB,MAAM5G,GAAI,MAASwG,IAW3E,SAAmBpM,EAAeyM,EAAUC,GAExC,IAAIC,EAAQ,GAGRC,EAAU,GAEVC,EAAcH,EAAcN,MAE5BU,EAAMvM,SAASO,eAAed,EAAcS,IAAIkB,WAAW,MAG3D0C,EAAYyI,EAAI1I,aAAa,EAAG,EAAGpE,EAAcJ,MAAOI,EAAcH,QACtEyE,EAAOD,EAAUC,KACrBqI,EAAMtL,KAAKqL,GACX,KAAwB,IAAjBC,EAAM9I,QAAc,CAEvB,IAAIkJ,EAAYJ,EAAMxC,MAEtByC,EAAQG,EAAUpH,EAAI,IAAMoH,EAAUnH,GAAK,EAE3C,IAIItH,EAAG0O,EAAGC,EAJNC,EAAgBH,EAAUpH,EAAI,EAC9BwH,EAAiBJ,EAAUpH,EAAI,EAC/ByH,EAAeL,EAAUnH,EAAI,EAC7ByH,EAAkBN,EAAUnH,EAAI,EAGhCwH,GAAgB,QAAmDzI,IAA9CiI,EAAQG,EAAUpH,EAAI,IAAMyH,KAEjD9O,EAAK8O,EAAepN,EAAcJ,MAAS,EAAyB,GAAnBmN,EAAUpH,EAAI,GAE/DsH,GADAD,EAAI1O,EAAI,GACA,EACJuO,IAAgB,OAASvI,EAAKhG,GAAK,IAAMgG,EAAK0I,GAAK,IAAM1I,EAAK2I,GAAK,KAEnEN,EAAMtL,KAAK,CAAE,EAAK0L,EAAUpH,EAAG,EAAKyH,EAAc,MAASL,EAAUX,SAIzEe,EAAiBnN,EAAcJ,YAAyD+E,IAAhDiI,EAAQO,EAAiB,IAAMJ,EAAUnH,KACjFtH,EAAKyO,EAAUnH,EAAI5F,EAAcJ,MAAS,EAA4B,GAAtBuN,EAAiB,GAEjEF,GADAD,EAAI1O,EAAI,GACA,EACJuO,IAAgB,OAASvI,EAAKhG,GAAK,IAAMgG,EAAK0I,GAAK,IAAM1I,EAAK2I,GAAK,KAEnEN,EAAMtL,KAAK,CAAE,EAAK8L,EAAgB,EAAKJ,EAAUnH,EAAG,MAASmH,EAAUX,SAI3EiB,EAAkBrN,EAAcH,aAA2D8E,IAAjDiI,EAAQG,EAAUpH,EAAI,IAAM0H,KACtE/O,EAAK+O,EAAkBrN,EAAcJ,MAAS,EAAyB,GAAnBmN,EAAUpH,EAAI,GAElEsH,GADAD,EAAI1O,EAAI,GACA,EACJuO,IAAgB,OAASvI,EAAKhG,GAAK,IAAMgG,EAAK0I,GAAK,IAAM1I,EAAK2I,GAAK,KAEnEN,EAAMtL,KAAK,CAAE,EAAK0L,EAAUpH,EAAG,EAAK0H,EAAiB,MAASN,EAAUX,SAI5Ec,GAAiB,QAAoDvI,IAA/CiI,EAAQM,EAAgB,IAAMH,EAAUnH,KAC9DtH,EAAKyO,EAAUnH,EAAI5F,EAAcJ,MAAS,EAA2B,GAArBsN,EAAgB,GAEhED,GADAD,EAAI1O,EAAI,GACA,EACJuO,IAAgB,OAASvI,EAAKhG,GAAK,IAAMgG,EAAK0I,GAAK,IAAM1I,EAAK2I,GAAK,KAEnEN,EAAMtL,KAAK,CAAE,EAAK6L,EAAe,EAAKH,EAAUnH,EAAG,MAASmH,EAAUX,SAI9E9N,EAAKyO,EAAUnH,EAAI5F,EAAcJ,MAAS,EAAyB,GAAnBmN,EAAUpH,EAAI,GAE9DsH,GADAD,EAAI1O,EAAI,GACA,EACRgG,EAAKhG,GAAKmO,EAAS,GACnBnI,EAAK0I,GAAKP,EAAS,GACnBnI,EAAK2I,GAAKR,EAAS,GAGvBK,EAAIvI,aAAaF,EAAW,EAAG,GApFvBiJ,CAAUtM,EAAOhB,cAAe+E,EAAgBwH,GAEhDvL,EAAOhB,cAAcuN,oBAAoB,QAAS5B,IAEtD3K,EAAOhB,cAAcyC,iBAAiB,QAASkJ,OAyFvDhM,KAAK6N,YAAc,SAAUtE,GAEzBxG,EAAE,IAAMwG,GAAWe,OAAM,WACrB,IAAIjJ,EAAS2H,EAAc3E,eAEvBpE,EAAQoB,EAAOhB,cAAciC,aAAa,SAC1CpC,EAASmB,EAAOhB,cAAciC,aAAa,UAC3CF,EAAUf,EAAOhB,cAAc2B,WAAW,MAC9C8L,QAAQC,IAAI,CACRC,kBAAkB3M,EAAOhB,cAAe,EAAG,EAAGJ,EAAOC,KACtD+N,MAAK,SAAUC,GACd9L,EAAQC,UAAU,EAAG,EAAGpC,EAAOC,GAC/BkC,EAAQ+L,UAAUlO,EAAQ,EAAGC,EAAS,GACtCkC,EAAQgM,OAAQ9C,KAAKC,GAAM,KAC3BnJ,EAAQ+L,WAAWlO,EAAQ,GAAIC,EAAS,GAExCkC,EAAQH,UAAUiM,EAAO,GAAI,EAAG,UAQ5ClO,KAAKqO,eAAiB,SAAU9E,GAC5BxG,EAAE,IAAMwG,GAAWe,OAAM,WACrB,IAAIjJ,EAAS2H,EAAc3E,eACvBjC,EAAUf,EAAOhB,cAAc2B,WAAW,MAC9CI,EAAQC,UAAU,EAAG,EAAGhB,EAAOhB,cAAciC,aAAa,SAAUjB,EAAOhB,cAAciC,aAAa,WACtGF,EAAQG,UAAY,UACpBH,EAAQI,SAAS,EAAG,EAAGnB,EAAOhB,cAAciC,aAAa,SAAUjB,EAAOhB,cAAciC,aAAa,eAO7GtC,KAAKsO,KAAO,SAAU/E,GAClBxG,EAAE,IAAMwG,GAAWe,OAAM,WACrB,IAAIjJ,EAAS2H,EAAc3E,eACvBjC,EAAUf,EAAOhB,cAAc2B,WAAW,MAC1C/B,EAAQoB,EAAOhB,cAAciC,aAAa,SAC1CpC,EAASmB,EAAOhB,cAAciC,aAAa,UAQ/C,GANAyG,EAAM9D,uBAAuBsJ,QAAQnM,EAAQqC,aAAa,EAAG,EAAGxE,EAAOC,IAEvEkC,EAAQC,UAAU,EAAG,EAAGpC,EAAOC,GAI3B6I,EAAM9D,uBAAuBf,QAAU,EAAG,CAC1C,IAAIsK,EAAkBzF,EAAM9D,uBAAuBuF,MACnDpI,EAAQwC,aAAa4J,EAAiB,EAAG,QAOrDxO,KAAKyO,YAAc,SAAUlF,GACzBxG,EAAE,IAAMwG,GAAWe,OAAM,WACrB,IAMQoE,EANJrN,EAAS2H,EAAc3E,eAW3B,SAASsK,EAAQlH,GACb,IAAImH,EAAM,IAAIC,MACVC,EAAS,IAAIC,WACbC,EAAOvH,EAAEI,OAAOoH,MAAM,GACrBD,EAAKrH,KAAKuH,MAAM,YAKrBN,EAAIO,OAAS,WAKT,IAAI9O,EAAgBgB,EAAOhB,cACvB+B,EAAU/B,EAAc2B,WAAW,MACnC9B,EAAS0O,EAAI1O,OACbD,EAAQ2O,EAAI3O,MACX2O,EAAI3O,MAAQ2O,EAAI1O,QAAW,KAE5BG,EAAcwC,aAAa,SAAUyI,KAAKuB,MAAM,MAChDxM,EAAcwC,aAAa,QAASyI,KAAKuB,MAAM,IAAM,MACrD3M,EAASG,EAAcH,OACvBD,EAAQI,EAAcJ,OAEhB2O,EAAI1O,OAAS0O,EAAI3O,OAAU,KAEjCI,EAAcwC,aAAa,QAASyI,KAAKuB,MAAM,MAC/CxM,EAAcwC,aAAa,SAAUyI,KAAKuB,MAAM,IAAM,MACtD3M,EAASG,EAAcH,OACvBD,EAAQI,EAAcJ,QAItBC,EAASmB,EAAOnB,OAChBD,EAAQoB,EAAOpB,MACfI,EAAcwC,aAAa,SAAU3C,GACrCG,EAAcwC,aAAa,QAAS5C,IAExCmC,EAAQH,UAAU2M,EAAK,EAAG,EAAG3O,EAAOC,GAEpC+I,EAAc2F,EAEd7F,EAAM9D,uBAAuBvD,KAAKU,EAAQqC,aAAa,EAAG,EAAGxE,EAAOC,KAGxE4O,EAAOM,UAAY,WACfR,EAAIS,IAAMP,EAAOQ,QAGrBR,EAAOS,cAAcP,IA7CjBtC,QAAQC,IAAI,sBAVZ+B,EAAQ9N,SAASC,cAAc,UAC7B8G,KAAO,OACb+G,EAAM5L,iBAAiB,SAAU6L,GAAS,GAC1CD,EAAMpE,YA2DlBtK,KAAKwP,WAAa,WACd,GAAIvG,EAAa,CACb,IAAI5H,EAAS2H,EAAc3E,eACvBjC,EAAUf,EAAOhB,cAAc2B,WAAW,MAC1C9B,EAASmB,EAAOhB,cAAciC,aAAa,UAC3CrC,EAAQoB,EAAOhB,cAAciC,aAAa,SAC9CF,EAAQH,UAAUgH,EAAa,EAAG,EAAGhJ,EAAOC,KAMpDF,KAAKyP,SAAW,SAAUlG,GACtBxG,EAAE,IAAMwG,GAAWe,OAAM,WAEV1J,SAASO,eAAeE,EAAOhB,cAAcS,IAAI4O,QAAO,SAAUC,GACzE,IAAIC,EAAMC,IAAIC,gBAAgBH,GAC1BI,EAAOnP,SAASC,cAAc,KAClCkP,EAAKC,KAAOJ,EACZ,IAAIxR,EAAO6R,OAAO,oCACL,OAAT7R,IAIA2R,EAAKN,SAAWrR,EAEhB2R,EAAKzF,gBAerB,IAAIN,EAAUhK,KACVkQ,EAAU,WACNlG,EAAQ7F,cACJ6F,EAAQX,cACUW,EAAQX,YACde,YAAc,WAAapB,EAAc9F,aAAe,GAAK,aAAe7B,EAAOlB,aAAe,MAItHgQ,EAAW,WACPnG,EAAQ5F,cACJ4F,EAAQX,cACUW,EAAQX,YACde,YAAc,WAAapB,EAAc9F,aAAe,GAAK,aAAe7B,EAAOlB,aAAe,MAI1HH,KAAKoQ,YAAc,WACfC,cAAcnH,GACdA,EAAO,KACPA,EAAOoH,YAAYJ,EAASlQ,KAAKmJ,eAErCnJ,KAAKuQ,aAAe,WAChBF,cAAcnH,GACdA,EAAO,KAIPA,EAAOoH,YAAYH,EAAUnQ,KAAKmJ,eAEtCnJ,KAAKwQ,KAAO,WACRH,cAAcnH,GACdA,EAAO,MAaXlJ,KAAKyQ,OAAS,SAAUlH,GAChBA,IACA3I,SAASO,eAAeoI,GAAWa,YAAc,kBAOrD,IALA,IAAIsG,EAAM,IAAIC,IAAI,CACdC,QAAS,EACTC,QAAS,KAGJhT,EAAI,EAAGA,EAAImL,EAAc5F,UAAUc,OAAQrG,IAAK,CACrD,IAAIiT,EAAalQ,SAASC,cAAc,UACxCiQ,EAAW7Q,MAAQ,IACnB6Q,EAAW5Q,OAAS,IACpB,IAAI6Q,EAAUD,EAAW9O,WAAW,MACpC+O,EAAQxO,UAAY,QACpBwO,EAAQvO,SAAS,EAAG,EAAG,IAAK,KAG5B,IAFA,IAAIwO,EAAgBD,EAAQtM,aAAa,EAAG,EAAGqM,EAAW7Q,MAAO6Q,EAAW5Q,QACxE+Q,EAAYjI,EAAc5F,UAAUvF,GAC/BqT,EAAI,EAAGA,EAAID,EAAU7Q,WAAW8D,OAAQgN,IAAK,CAGlD,IAFA,IAAItN,EAAQqN,EAAU7Q,WAAW8Q,GAC7BxM,EAAYd,EAAM5B,WAAW,MAAMyC,aAAa,EAAG,EAAGb,EAAM3D,MAAO2D,EAAM1D,QAAQyE,KAC5EwM,EAAI,EAAGA,EAAIzM,EAAUR,OAAQiN,GAAK,EAClB,MAAjBzM,EAAUyM,IAAmC,MAArBzM,EAAUyM,EAAI,IAAmC,MAArBzM,EAAUyM,EAAI,KAMlEH,EAAcrM,KAAKwM,GAAKzM,EAAUyM,GAClCH,EAAcrM,KAAKwM,EAAI,GAAKzM,EAAUyM,EAAI,GAC1CH,EAAcrM,KAAKwM,EAAI,GAAKzM,EAAUyM,EAAI,GAC1CH,EAAcrM,KAAKwM,EAAI,GAAK,KAIpCJ,EAAQnM,aAAaoM,EAAe,EAAG,GAG3CN,EAAIU,SAASN,EAAY,CAAEO,MAAOrR,KAAKmJ,eAE3CuH,EAAIlJ,GAAG,YAAY,SAAUmI,GACzB/O,SAASO,eAAeoI,GAAWa,YAAc,GACjD,IAAIkH,EAASzB,IAAIC,gBAAgBH,GACjC4B,OAAOC,KAAKF,MAEhBZ,EAAIe,UAYRzR,KAAK0R,KAAO,SAAUnI,GAClBxG,EAAE,IAAMwG,GAAWe,OAAM,WAErB,IAAIlM,EAAO6R,OAAO,kBAClB,GAAa,KAAT7R,EACAA,EAAO,0BAEN,GAAa,OAATA,EACL,OAEJ,IAAIuT,EAAY,GAChB3I,EAAc5F,UAAUxB,SAAQ,SAAU6B,GAEtC,IAAIQ,EAAWR,EAAMjD,cACrByD,EAAQ,OAAa,GACrBR,EAAMrD,WAAWwB,SAAQ,SAAUgC,GAE/B,IAAIgO,EAAW,CACX,GAAMhO,EAAM9C,GACZ,MAAS8C,EAAMtB,aAAa,UAC5B,OAAUsB,EAAMtB,aAAa,SAC7B,OAAUsB,EAAM5C,MAAME,OACtB,QAAW0C,EAAM5C,MAAMC,SAG3B2Q,EAAQ,UAAgBhO,EAAMiO,YAC9B5N,EAAS6N,OAAOpQ,KAAKkQ,MAEzBD,EAAUjQ,KAAKqQ,KAAKC,UAAU/N,OAElC,IAAIgO,EAAO,MACXA,GAAQN,EAAUO,KAAK,OACvBD,GAAQ,MAER,IAAItC,EAAO,IAAIwC,KAAK,CAACF,GAAO,CAAEtK,KAAM,qBAChCiI,EAAMC,IAAIC,gBAAgBH,GAC1BI,EAAOnP,SAASC,cAAc,KAClCkP,EAAKC,KAAOJ,EACZG,EAAKN,SAAWrR,EAAO,QACvB2R,EAAKzF,YAGbtK,KAAKoS,cAAgB,SAAU7I,EAAW8I,GACtC,IAAIC,EAAOtS,KACX+C,EAAE,IAAMwG,GAAWe,OAAM,WAGrB,IACQoE,EAKR,SAASC,EAAQlH,GACb,IAAIqH,EAAS,IAAIC,WACbC,EAAOvH,EAAEI,OAAOoH,MAAM,GAE1BH,EAAOK,OACI,SAAU1H,GAGb,IAAI9C,EACJ,IACIA,EAAOoN,KAAKQ,MAAM9K,EAAEI,OAAOyH,QAE/B,MAAO7H,GAEH,OAKC9C,EAAK,KAAQA,EAAK,GAAGvG,MAASuG,EAAK,GAAGzE,QAAWyE,EAAK,GAAG1E,OAAU0E,EAAK,GAAGA,OAKhFqE,EAAcxF,eAEV8O,EAAKjJ,cAGLiJ,EAAKjJ,YAAYe,YAAc,WAAapB,EAAc9F,aAAe,GAAK,aAAe7B,EAAOlB,aAAe,IAGvHwE,EAAK/C,SAAQ,SAAU6B,EAAO+O,GACtBA,EAAQ,GAERxJ,EAAcjF,cAKlB,IAAIkN,EAAYjI,EAAc5F,UAAUoP,GACxC9F,QAAQC,IAAI,eAAiBlJ,EAAMqO,OAAO5N,OAAS,uBAAyBsO,EAAQ,IACpF,IAAIC,EAA4BhP,EAAMqO,OAClCY,EAA6BzB,EAAU7Q,WAC3CqS,EAA0B7Q,SAAQ,SAAUgC,EAAOC,GAC1CA,EAAa,EAAK6O,EAA2BxO,SAE9CwI,QAAQC,IAAI,sCAAwC6F,GACpDxJ,EAAc5F,UAAUoP,GAAO9R,iBAEnC,IAAIyB,EAAY6G,EAAc5F,UAAUoP,GAAOpS,WAAWyD,GAE1D1B,EAAUnB,MAAMC,QAAU2C,EAAM3C,QAChCkB,EAAUnB,MAAME,OAAS0C,EAAM1C,OAC/BiB,EAAUjC,OAAS0D,EAAM1D,OACzBiC,EAAUlC,MAAQ2D,EAAM3D,MAIxB,SAAWmC,EAASuQ,GAChBA,EAAMxD,OAAS,WACX/M,EAAQH,UAAU0Q,EAAO,EAAG,IAEhCA,EAAMtD,IAAMzL,EAAMc,UAJtB,CAFavC,EAAUH,WAAW,MACxB,IAAI6M,cAtClBnC,QAAQC,IAAI,6CAiDxBmC,EAAO8D,WAAW5D,IA1EdN,EAAQ9N,SAASC,cAAc,UAC7B8G,KAAO,OACb+G,EAAM5L,iBAAiB,SAAU6L,GAAS,GAC1CD,EAAMpE,YFpsBL,CAAY3J,EAAWkE,EAAU5B,GAClD6F,EAAWQ,WAAW,SACtBR,EAAWgB,WAAWlJ,UACtBkI,EAAWkC,iBAAiB,cAAe,KAC3ClC,EAAWiD,UAAU,aACrBjD,EAAWuB,YAAY,gBACvBvB,EAAW4B,YAAY,eAAgB,SACvC5B,EAAWuF,eAAe,eAC1BvF,EAAW+E,YAAY,qBACvB/E,EAAWwF,KAAK,QAChBxF,EAAW2G,SAAS,YACpB3G,EAAW2F,YAAY,eACvB3F,EAAW4I,KAAK,YAChB5I,EAAWsJ,cAAc,gBAAiB,SAC1CtJ,EAAWiC,kBAAkB,eAI7BnK,SAASO,eAAe,UAAU2B,iBAAiB,QAAS,KAC3D,GAAGgG,EAAWW,OAAO,CACpB,IAAIC,EAAOzG,EAAQoB,eACnBzD,SAASO,eAAe,SAASiJ,YAAc,WAAanH,EAAQC,aAAa,GAAK,aAAewG,EAAKvJ,aAAe,MAI3HS,SAASO,eAAe,WAAW2B,iBAAiB,QAAS,KAC5D,GAAGgG,EAAWU,KAAK,CAClB,IAAIE,EAAOzG,EAAQoB,eACnBzD,SAASO,eAAe,SAASiJ,YAAc,WAAanH,EAAQC,aAAa,GAAK,aAAewG,EAAKvJ,aAAe,MAK3HS,SAASO,eAAe,aAAa2B,iBAAiB,QAAS,KAC9D,GAAGgG,EAAW1E,YAAY,CACzB,IAAIsF,EAAOzG,EAAQoB,eACnBzD,SAASO,eAAe,SAASiJ,YAAc,WAAanH,EAAQC,aAAa,GAAK,aAAewG,EAAKvJ,aAAe,MAI3HS,SAASO,eAAe,aAAa2B,iBAAiB,QAAS,KAC9D,GAAGgG,EAAW3E,YAAY,CACzB,IAAIuF,EAAOzG,EAAQoB,eACnBzD,SAASO,eAAe,SAASiJ,YAAc,WAAanH,EAAQC,aAAa,GAAK,aAAewG,EAAKvJ,aAAe,MAI3HS,SAASO,eAAe,eAAe2B,iBAAiB,QAAS,KAChEgG,EAAW2H,OAAO,mBAGnB7P,SAASO,eAAe,sBAAsB2B,iBAAiB,QAAS,KACvE+P,QAAUjS,SAASO,eAAe,sBAC/B2H,EAAWM,WACbN,EAAWM,WAAY,EACvByJ,QAAQzI,YAAc,4CAEtBtB,EAAWM,WAAY,EACvByJ,QAAQzI,YAAc,6CAKP,IGjFjB,SAAiB/I,EAAQ0H,GACrB,IAAI+J,EAGAR,EAAOtS,KA8VX,SAAS+S,EAASC,EAAKC,GACnB,IAAI7Q,EAAUf,EAAOhB,cAAc2B,WAAW,MAC9CI,EAAQwE,SAAW,QACnBxE,EAAQ8E,UAAY,EACpB9E,EAAQyE,YACRzE,EAAQ0E,OAAOkM,EAAKC,GACpB7Q,EAAQ2E,OAAOiM,EAAM,EAAGC,EAAM,GAC9B7Q,EAAQ4E,YACR5E,EAAQ6E,YAAc,OACtB7E,EAAQ+E,SAQZ,SAAS+L,EAAQC,EAASC,EAAMC,EAAMC,GAYlC,IAVA,IAAI3O,EAAOwO,EAAQxO,KACfzE,EAASoL,KAAKiI,KAAK5O,EAAKT,OAAS,GACjCjE,EAAQqL,KAAKiI,KAAK5O,EAAKT,OAAS,GAKhCsP,EAAU,IAAIC,kBAAkB9O,GAChC+O,EAAe,EAEVzN,EAAI,EAAGA,EAAI/F,EAAQ+F,IAMxB,IAJA,IAAI0N,EAAS,EAAI1N,EAAM/F,EAAU,EAE7B0T,EAASD,EAAQA,EAEZ3N,EAAI,EAAGA,EAAI/F,EAAO+F,IAAK,CAI5B,IAAI6N,EAAuB,EAAfH,EAERI,EAAS,EAAI9N,EAAM/F,EAAS,EAE5B8T,EAASD,EAAQA,EAEjBE,EAAO1I,KAAKiI,KAAKQ,EAASH,GAI9B,GAAK,GAAKI,GAAUA,GAAQ,EAAI,CAC5B,IAAIC,EAAO3I,KAAKiI,KAAK,EAAIS,EAAOA,GAIhC,IAFAC,GAAQD,GAAQ,EAAIC,IAAS,IAEjB,EAAG,CAEX,IAAIC,EAAQ5I,KAAK6I,MAAMR,EAAOG,GAE1BM,EAAOH,EAAO3I,KAAK+I,IAAIH,GAEvBI,EAAOL,EAAO3I,KAAKiJ,IAAIL,GAEvBM,EAAKlJ,KAAKuB,OAAQuH,EAAO,GAAMnU,EAAU,GACzCwU,EAAKnJ,KAAKuB,OAAQyH,EAAO,GAAMpU,EAAW,GAC9CwU,OAAWzU,EAAUwU,EAAOD,EAC5BE,QAAU,EACV/P,EAAKkP,GAASL,EAAQkB,QACtB/P,EAAKkP,EAAQ,GAAKL,EAAQkB,OAAS,GACnC/P,EAAKkP,EAAQ,GAAKL,EAAQkB,OAAS,GACnC/P,EAAKkP,EAAQ,GAAKL,EAAQkB,OAAS,IAG3ChB,IAGSrS,EAAOhB,cAAc2B,WAAW,MAEtC4C,aAAauO,EAASC,EAAOE,EAAKD,EAAOC,GA0CxD,SAASqB,EAAYhW,EAAG0O,EAAGC,EAAGsH,EAAIC,EAAIC,EAAIC,GACtC,IAAIC,EAAM1J,KAAK2J,IAAItW,EAAIiW,IAAOG,EAC1BG,EAAQ5J,KAAK2J,IAAI5H,EAAIwH,IAAOE,EAC5BI,EAAO7J,KAAK2J,IAAI3H,EAAIwH,IAAOC,EAC/B,SAAIC,GAAOE,GAASC,GAwSxB,SAASC,EAAMpP,EAAGC,EAAGtH,EAAG0O,EAAGC,GACvBtN,KAAKgG,EAAIA,EACThG,KAAKiG,EAAIA,EACTjG,KAAKrB,EAAIA,EACTqB,KAAKqN,EAAIA,EACTrN,KAAKsN,EAAIA,EAEb,SAAS+H,EAAKC,EAAOC,GACjBvV,KAAK2E,KAAO,CAAC2Q,EAAMtP,EAAGsP,EAAMrP,GAC5BjG,KAAKsV,MAAQA,EACbtV,KAAKuV,IAAMA,EACXvV,KAAKwB,KAAO,KACZxB,KAAKwV,MAAQ,KAEjB,SAASC,EAAejD,EAAOvS,EAAOC,GAOlC,GAAa,EAARD,EAAaC,EAASsS,EAEvB,MAAO,GAEX,IAAIkD,EAAWpK,KAAKuB,MAAM2F,EAAQ,GAC9BmD,EAASrK,KAAKuB,MAAM6I,EAAWzV,GAEnC,MAAO,CAAE,EADIyV,EAAYC,EAAS1V,EACZ,EAAK0V,GAE/B,SAASC,EAAQC,EAAIrB,EAAIsB,EAAIrB,GAIzB,OAAOnJ,KAAKyK,IAAIF,EAAKrB,EAAI,GAAKlJ,KAAKyK,IAAID,EAAKrB,EAAI,GAsGpD,SAASuB,EAAoBC,EAAMjQ,EAAGC,GAClC,IAAIiQ,EAAS,GAMb,OAJAA,EAAOC,gBAAkBF,EAAKX,MAC9BY,EAAOE,QAAUR,EAAQK,EAAKtR,KAAK,GAAIqB,EAAGiQ,EAAKtR,KAAK,GAAIsB,GAK5D,SAASoQ,EAA0BJ,EAAMC,EAAQlQ,EAAGC,GAChD,GA/DYqQ,EA+DDL,EA9DU,OAAdK,EAAK9U,MAAgC,OAAf8U,EAAKd,MA8DhB,CACd,IAAIxB,EAAO4B,EAAQK,EAAKtR,KAAK,GAAIqB,EAAGiQ,EAAKtR,KAAK,GAAIsB,GAC9C+N,EAAOkC,EAAOE,UACdF,EAAOC,gBAAkBF,EAAKX,MAC9BY,EAAOE,QAAUpC,OAGpB,CAOD,GALAuC,SAAWX,EAAQK,EAAKtR,KAAK,GAAIqB,EAAGiQ,EAAKtR,KAAK,GAAIsB,GAC9CsQ,SAAWL,EAAOE,UAClBF,EAAOC,gBAAkBF,EAAKX,MAC9BY,EAAOE,QAAUG,UAEjBN,EAAKzU,OAASyU,EAAKT,MAEnBa,EAA0BJ,EAAKzU,KAAM0U,EAAQlQ,EAAGC,QAIX,IAAbgQ,EAAKV,IAAavP,EAAIC,KACrBD,EAEjBA,EAAIiQ,EAAKtR,KAAK,IACd0R,EAA0BJ,EAAKT,MAAOU,EAAQlQ,EAAGC,GAE7CD,EAAIkQ,EAAOE,QAAUH,EAAKtR,KAAK,IAC/B0R,EAA0BJ,EAAKzU,KAAM0U,EAAQlQ,EAAGC,KAIpDoQ,EAA0BJ,EAAKzU,KAAM0U,EAAQlQ,EAAGC,GAC5CD,EAAIkQ,EAAOE,QAAUH,EAAKtR,KAAK,IAI/B0R,EAA0BJ,EAAKT,MAAOU,EAAQlQ,EAAGC,IAKrDA,EAAIgQ,EAAKtR,KAAK,IACd0R,EAA0BJ,EAAKT,MAAOU,EAAQlQ,EAAGC,GAC7CA,EAAIiQ,EAAOE,QAAUH,EAAKtR,KAAK,IAC/B0R,EAA0BJ,EAAKzU,KAAM0U,EAAQlQ,EAAGC,KAIpDoQ,EAA0BJ,EAAKzU,KAAM0U,EAAQlQ,EAAGC,GAC5CA,EAAIiQ,EAAOE,QAAUH,EAAKtR,KAAK,IAC/B0R,EAA0BJ,EAAKT,MAAOU,EAAQlQ,EAAGC,IAjHzE,IAAgBqQ,EA2DZD,CAA0BJ,EAAMC,EAAQlQ,EAAGC,GACpCiQ,EAAOC,gBA94BlBnW,KAAKwW,aAAe,SAAUC,GAC1B,IAAIrU,EAAUf,EAAOhB,cAAc2B,WAAW,MAC1C/B,EAAQoB,EAAOhB,cAAciC,aAAa,SAC1CpC,EAASmB,EAAOhB,cAAciC,aAAa,UAC3C6Q,EAAU/Q,EAAQqC,aAAa,EAAG,EAAGxE,EAAOC,GAE5C4S,GACA/J,EAAM9D,uBAAuBvD,KAAKoR,GAEtC2D,EAAOtD,GACP/Q,EAAQwC,aAAauO,EAAS,EAAG,GACjCL,EAAYK,GAGhBnT,KAAK0W,mBAAqB,SAAUC,GAChC3W,KAAKwW,aAAaxW,KAAK2W,KAO3B3W,KAAK4W,UAAY,SAAUC,GAEvB,IADA,IAAI1Y,EAAI0Y,EAAOlS,KACN9G,EAAI,EAAGA,EAAIM,EAAE+F,OAAQrG,GAAK,EAAG,CAClC,IAAIc,EAAIR,EAAEN,GACNwP,EAAIlP,EAAEN,EAAI,GACVyP,EAAInP,EAAEN,EAAI,GAEdM,EAAEN,GAAKM,EAAEN,EAAI,GAAKM,EAAEN,EAAI,IAAMc,EAAI0O,EAAIC,GAAK,EAE/C,OAAOuJ,GAKX7W,KAAK8W,MAAQ,SAAUD,GAEnB,IADA,IAAI1Y,EAAI0Y,EAAOlS,KACN9G,EAAI,EAAGA,EAAIM,EAAE+F,OAAQrG,GAAK,EAAG,CAClC,IAAIc,EAAIR,EAAEN,GACNwP,EAAIlP,EAAEN,EAAI,GACVyP,EAAInP,EAAEN,EAAI,GACdM,EAAEN,GAAU,GAAJc,EAAe,GAAJ0O,EAAe,GAAJC,EAC9BnP,EAAEN,EAAI,GAAU,GAAJc,EAAe,GAAJ0O,EAAe,GAAJC,EAClCnP,EAAEN,EAAI,GAAU,GAAJc,EAAe,GAAJ0O,EAAe,GAAJC,EAEtC,OAAOuJ,GAMX7W,KAAK+W,SAAW,SAAUF,GActB,IAbA,IACI1Y,EAAI0Y,EAAOlS,KAUXqS,EARO,OAQF,IAEAnZ,EAAI,EAAGA,EAAIM,EAAE+F,OAAQrG,GAAK,EAAG,CAClC,IAAIc,EAAIR,EAAEN,GACNwP,EAAIlP,EAAEN,EAAI,GACVyP,EAAInP,EAAEN,EAAI,GACdM,EAAEN,GAXG,OAWEc,EAAS0O,EAAI2J,GALf,KAKoB1J,EACzBnP,EAAEN,EAAI,IARD,MAQMc,EAAS0O,GAfb,OAIF,IAPa,MAYb,KAMwBC,EAC7BnP,EAAEN,EAAI,IATD,MASMc,EAAS0O,EAAI2J,EAXnB,MAWwB1J,EAEjC,OAAOuJ,GAMX7W,KAAKiX,KAAO,SAAUJ,GAElB,IADA,IAAI1Y,EAAI0Y,EAAOlS,KACN9G,EAAI,EAAGA,EAAIM,EAAE+F,OAAQrG,GAAK,EAAG,CAClC,IAAIc,EAAIR,EAAEN,GACNwP,EAAIlP,EAAEN,EAAI,GACVyP,EAAInP,EAAEN,EAAI,GACdM,EAAEN,GAAKyP,EACPnP,EAAEN,EAAI,GAAKc,EACXR,EAAEN,EAAI,GAAKwP,EAEf,OAAOwJ,GAMX7W,KAAKkX,OAAS,SAAUL,GAEpB,IADA,IAAI1Y,EAAI0Y,EAAOlS,KACN9G,EAAI,EAAGA,EAAIM,EAAE+F,OAAQrG,GAAK,GAAI,CAC3BM,EAAEN,GACFM,EAAEN,EAAI,GACNM,EAAEN,EAAI,GACdM,EAAEN,GAAK,UACPM,EAAEN,EAAI,GAAK,UACXM,EAAEN,EAAI,GAAK,YAQnBmC,KAAKmX,aAAe,SAAUN,GAE1B,IADA,IAAI1Y,EAAI0Y,EAAOlS,KACN9G,EAAI,EAAGA,EAAIM,EAAE+F,OAAQrG,IAAK,CAC/B,IAAIc,EAAIR,EAAEN,GACNwP,EAAIlP,EAAEN,EAAI,GACVyP,EAAInP,EAAEN,EAAI,GACdM,EAAEN,EAAI,GAAKyP,EACXnP,EAAEN,EAAI,GAAKwP,EACXlP,EAAEN,GAAKc,EAEX,OAAOkY,GAMX7W,KAAKoX,UAAY,SAAUP,GAGvB,IADA,IAAI1Y,EAAI0Y,EAAOlS,KACN9G,EAAI,EAAGA,EAAIM,EAAE+F,OAAQrG,GAAK,EAAG,CAClC,IAAIc,EAAIR,EAAEN,GACNwP,EAAIlP,EAAEN,EAAI,GACNM,EAAEN,EAAI,GACNM,EAAEN,EAAI,GACVwP,GAAK1O,IACLR,EAAEN,EAAI,GAAgB,EAAXM,EAAEN,EAAI,GACjBM,EAAEN,EAAI,GAAKM,EAAEN,EAAI,GAAK,GAG9B,OAAOgZ,GAMX7W,KAAKqX,MAAQ,SAAUR,GAenB,IAdA,IACI1Y,EAAI0Y,EAAOlS,KAWXqS,EARO,OAQF,IAEAnZ,EAAI,EAAGA,EAAIM,EAAE+F,OAAQrG,GAAK,EAAG,CAClC,IAAIc,EAAIR,EAAEN,GACNwP,EAAIlP,EAAEN,EAAI,GACVyP,EAAInP,EAAEN,EAAI,GACdM,EAAEN,GAXG,MAWEc,EAAS0O,EAAI2J,GALf,MAKoB1J,EACzBnP,EAAEN,EAAI,IARD,KAQMc,EAAS0O,GAfb,OAIF,IARa,MAab,MAMwBC,EAC7BnP,EAAEN,EAAI,IATD,KASMc,EAAS0O,EAAI2J,EAXnB,OAWwB1J,EAEjC,OAAOuJ,GAMX7W,KAAKsX,SAAW,SAAUT,GAEtB,IADA,IAAI1Y,EAAI0Y,EAAOlS,KACN9G,EAAI,EAAGA,EAAIM,EAAE+F,OAAQrG,IAAK,CAC/B,IAAIc,EAAIR,EAAEN,GACNwP,EAAIlP,EAAEN,EAAI,GACNM,EAAEN,EAAI,GACVwP,EAAI,KAAOA,EAAI,MACflP,EAAEN,EAAI,GAAK,GAEXc,EAAI,MACJR,EAAEN,GAAY,EAAPM,EAAEN,IAGjB,OAAOgZ,GAMX7W,KAAKuX,UAAY,SAAUV,GAEvB,IADA,IAAI1Y,EAAI0Y,EAAOlS,KACN9G,EAAI,EAAGA,EAAIM,EAAE+F,OAAQrG,GAAK,EAAG,CAClC,IAAI2Z,EAAOlM,KAAKuB,MAAsB,EAAhBvB,KAAKmM,SAAe,GACtC9Y,EAAIR,EAAEN,GACNwP,EAAIlP,EAAEN,EAAI,GACVyP,EAAInP,EAAEN,EAAI,GACVwO,EAAIlO,EAAEN,EAAI,GAEd,GAAU,MAANc,GAAmB,MAAN0O,GAAmB,MAANC,EAI1B,OAAQkK,GACJ,KAAK,EACG3Z,GAAK,MAELM,EAAEN,EAAI,MAAQc,EACdR,EAAEN,EAAI,MAAQwP,EACdlP,EAAEN,EAAI,MAAQyP,EACdnP,EAAEN,EAAI,MAAQwO,IAGdlO,EAAEN,EAAI,MAAQc,EACdR,EAAEN,EAAI,MAAQwP,EACdlP,EAAEN,EAAI,MAAQyP,EACdnP,EAAEN,EAAI,MAAQwO,GAElB,MACJ,KAAK,EAEDlO,EAAEN,EAAI,MAAQc,EACdR,EAAEN,EAAI,MAAQwP,EACdlP,EAAEN,EAAI,MAAQyP,EACdnP,EAAEN,EAAI,MAAQwO,EACd,MACJ,KAAK,EACDlO,EAAEN,EAAI,GAAKc,EACXR,EAAEN,EAAI,GAAKwP,EACXlP,EAAEN,EAAI,GAAKyP,EACXnP,EAAEN,EAAI,GAAKwO,EACX,MACJ,KAAK,EACDlO,EAAEN,EAAI,GAAKc,EACXR,EAAEN,EAAI,GAAKwP,EACXlP,EAAEN,EAAI,GAAKyP,EACXnP,EAAEN,EAAI,GAAKwO,GAQ3B,OAAOwK,GAMX7W,KAAK0X,OAAS,SAAUb,GAGpB,IAFA,IACIlY,EAAG0O,EAAGC,EADNnP,EAAI0Y,EAAOlS,KAEN9G,EAAI,EAAGA,EAAIM,EAAE+F,OAAQrG,GAAK,EAC/Bc,EAAIR,EAAEN,GACNwP,EAAIlP,EAAEN,EAAI,GACVyP,EAAInP,EAAEN,EAAI,GACVM,EAAEN,GAAK,IAAMc,EACbR,EAAEN,EAAI,GAAK,IAAMwP,EACjBlP,EAAEN,EAAI,GAAK,IAAMyP,EAErB,OAAOuJ,GASX7W,KAAK2X,OAAS,SAAUd,GACpB,IAAI1Y,EAAI0Y,EAAOlS,KAEXiT,EAAU,EADFvW,EAAOhB,cAAciC,aAAa,SAE9C,IAAKzE,EAAI,EAAGA,EAAIM,EAAE+F,OAAQrG,GAAK,EAAG,CAI9B,IAAIga,EAAqB7S,MAAZ7G,EAAEN,EAAI,GAEfia,EAAqB9S,MAAZ7G,EAAEN,EAAI,GAEfka,EAA6B/S,MAApB7G,EAAEN,EAAK+Z,GAEhBI,EAA6BhT,MAApB7G,EAAEN,EAAK+Z,GACpB,KAAKC,GAAUC,GAAUC,GAAUC,GAAO,CACtC,IAAI/D,EAAmB,GAAX9V,EAAEN,EAAI,GAAqB,GAAXM,EAAEN,EAAI,GAA6B,GAAnBM,EAAEN,EAAK+Z,GAAoC,GAAnBzZ,EAAEN,EAAK+Z,GAAwB,GAAPzZ,EAAEN,GAC1Foa,EAAmB,GAAX9Z,EAAEN,EAAI,GAAqB,GAAXM,EAAEN,EAAI,GAAiC,GAAvBM,EAAEN,GAAK+Z,EAAU,IAAkC,GAAvBzZ,EAAEN,GAAK+Z,EAAU,IAAsB,GAAXzZ,EAAEN,EAAI,GACtGqa,EAAmB,GAAX/Z,EAAEN,EAAI,GAAqB,GAAXM,EAAEN,EAAI,GAAiC,GAAvBM,EAAEN,GAAK+Z,EAAU,IAAkC,GAAvBzZ,EAAEN,GAAK+Z,EAAU,IAAsB,GAAXzZ,EAAEN,EAAI,GACtGsa,EAAmB,GAAXha,EAAEN,EAAI,GAAqB,GAAXM,EAAEN,EAAI,GAAiC,GAAvBM,EAAEN,GAAK+Z,EAAU,IAAkC,GAAvBzZ,EAAEN,GAAK+Z,EAAU,IAAsB,GAAXzZ,EAAEN,EAAI,GAC1GM,EAAEN,GAAKoW,EACP9V,EAAEN,EAAI,GAAKoa,EACX9Z,EAAEN,EAAI,GAAKqa,EACX/Z,EAAEN,EAAI,GAAKsa,GAGnB,OAAOtB,GASX7W,KAAKoY,QAAU,WACX,IAAInY,EAAQoB,EAAOhB,cAAciC,aAAa,SAC1CpC,EAASmB,EAAOhB,cAAciC,aAAa,UAC3CF,EAAUf,EAAOhB,cAAc2B,WAAW,MAE1C7D,EADUiE,EAAQqC,aAAa,EAAG,EAAGxE,EAAOC,GAChCyE,KACZ0T,EAAa,EACbC,EAAa,EACb/X,EAAQ,EACRqX,EAAU,EAAI3X,EAClBmC,EAAQC,UAAU,EAAG,EAAGpC,EAAOC,GAC/BkC,EAAQG,UAAY,OACpBH,EAAQI,SAAS,EAAG,EAAGvC,EAAOC,GAC9B,IAAK,IAAIrC,EAAI,EAAGA,EAAIM,EAAE+F,OAAQrG,GAAK,EAAG,CAClC,IAAIc,EAAIR,EAAEN,GACNwP,EAAIlP,EAAEN,EAAI,GACVyP,EAAInP,EAAEN,EAAI,GACduE,EAAQwE,SAAW,QACnBxE,EAAQ8E,UAAY,EACpB,IAAIqR,EAAMpa,EAAEN,EAAK+Z,GACbY,EAAMra,EAAEN,GAAK+Z,EAAU,IACvBa,EAAMta,EAAEN,GAAK+Z,EAAU,SAEF5S,IAArB7G,EAAEN,EAAK+Z,IAA4BjD,EAAYhW,EAAG0O,EAAGC,EAAGiL,EAAKC,EAAKC,EAAK,KACnElY,EAAQ,KACRA,IAEJwS,EAASsF,EAAYC,IAErBza,EAAK+Z,GAAY,GACjBU,IAEAD,GAAcpY,IACdoY,EAAa,GAEjBA,MAoFRrY,KAAK0Y,eAAiB,WAClB,IAAIzY,EAAQoB,EAAOhB,cAAciC,aAAa,SAC1CpC,EAASmB,EAAOhB,cAAciC,aAAa,UAE3CrC,IAAUC,GAKdgT,EAFc7R,EAAOhB,cAAc2B,WAAW,MAC3ByC,aAAa,EAAG,EAAGxE,EAAOC,GAC/B,EAAG,EAAG,IAwCxBF,KAAK2Y,UAAY,SAAU9B,GAKvB,IAJA,IAAI5W,EAAQoB,EAAOhB,cAAciC,aAAa,SAC1CnE,EAAI0Y,EAAOlS,KACXiU,EAAO,IAAInF,kBAAkBtV,GAC7ByZ,EAAU,EAAI3X,EACTpC,EAAI,EAAGA,EAAIM,EAAE+F,OAAQrG,GAAK,EAAG,CAElC,IAAIc,EAAIR,EAAEN,GACNwP,EAAIlP,EAAEN,EAAI,GACVyP,EAAInP,EAAEN,EAAI,GAEVgb,EAAMD,EAAK/a,EAAI,GACfib,EAAMF,EAAK/a,EAAI,GACfkb,EAAMH,EAAK/a,EAAI,GAEfmb,EAAMJ,EAAK/a,EAAI,GACfob,EAAML,EAAK/a,EAAI,GACfqb,EAAMN,EAAK/a,EAAI,GAEf0a,EAAMK,EAAK/a,EAAK+Z,GAChBY,EAAMI,EAAK/a,GAAK+Z,EAAU,IAC1Ba,EAAMG,EAAK/a,GAAK+Z,EAAU,IAE1BuB,EAAMP,EAAK/a,EAAK+Z,GAChBwB,EAAMR,EAAK/a,GAAK+Z,EAAU,IAC1ByB,EAAMT,EAAK/a,GAAK+Z,EAAU,IAE1B0B,EAAMV,EAAK/a,GAAK+Z,EAAU,IAC1B2B,EAAMX,EAAK/a,GAAK+Z,EAAU,IAC1B4B,EAAMZ,EAAK/a,GAAK+Z,EAAU,IAE1B6B,EAAMb,EAAK/a,GAAK+Z,EAAU,IAC1B8B,EAAMd,EAAK/a,GAAK+Z,EAAU,IAC1B+B,EAAMf,EAAK/a,GAAK+Z,EAAU,IAE1BgC,EAAMhB,EAAK/a,GAAK+Z,EAAU,IAC1BiC,EAAMjB,EAAK/a,GAAK+Z,EAAU,IAC1BkC,EAAMlB,EAAK/a,GAAK+Z,EAAU,IAE1BmC,EAAMnB,EAAK/a,GAAK+Z,EAAU,IAC1BoC,EAAMpB,EAAK/a,GAAK+Z,EAAU,IAC1BqC,EAAMrB,EAAK/a,GAAK+Z,EAAU,IAE1BC,OAAsB7S,IAAb7G,EAAEN,EAAI,GAEfia,OAAsB9S,IAAb7G,EAAEN,EAAI,GAEfka,OAA8B/S,IAArB7G,EAAEN,EAAK+Z,GAEhBI,OAA8BhT,IAArB7G,EAAEN,EAAK+Z,GAEhBsC,OAAkClV,IAAzB7G,EAAEN,GAAK+Z,EAAU,IAE1BuC,OAAkCnV,IAAzB7G,EAAEN,GAAK+Z,EAAU,IAE1BwC,OAAkCpV,IAAzB7G,EAAEN,GAAK+Z,EAAU,IAE1ByC,OAAkCrV,IAAzB7G,EAAEN,GAAK+Z,EAAU,IAC9B,KAAKC,GAAUC,GAAUC,GAAUC,GAAUkC,GAAUC,GAAUC,GAAUC,GAAO,CAE9E,IAAIC,EAAM1B,EAAK/a,EAAI,GACf0c,EAAM3B,EAAK/a,EAAI,GACf2c,EAAM5B,EAAK/a,EAAI,IAIf4c,EAAOtc,EAAEN,GAAK+Z,EAAU,IACxB8C,EAAOvc,EAAEN,GAAK+Z,EAAU,IACxB+C,EAAOxc,EAAEN,GAAK+Z,EAAU,KAO5B,IAAKjD,EAAYhW,EAAG0O,EAAGC,EAAGgN,EAAKC,EAAKC,EAAK,MACpC7F,EAAYhW,EAAG0O,EAAGC,EAAGmN,EAAMC,EAAMC,EAAM;AAEvC3B,GAAO,KAAOC,GAAO,KAAOC,GAAO,IACpC,SAIAvE,EAAYhW,EAAG0O,EAAGC,EAAGuL,EAAKC,EAAKC,EAFvB,KAGRpE,EAAYhW,EAAG0O,EAAGC,EAAG0L,EAAKC,EAAKC,EAHvB,KAIRvE,EAAYhW,EAAG0O,EAAGC,EAAGiL,EAAKC,EAAKC,EAJvB,KAKR9D,EAAYhW,EAAG0O,EAAGC,EAAG6L,EAAKC,EAAKC,EALvB,KAMR1E,EAAYhW,EAAG0O,EAAGC,EAAGgM,EAAKC,EAAKC,EANvB,KAOR7E,EAAYhW,EAAG0O,EAAGC,EAAGmM,EAAKC,EAAKC,EAPvB,KAQRhF,EAAYhW,EAAG0O,EAAGC,EAAGsM,EAAKC,EAAKC,EARvB,KASRnF,EAAYhW,EAAG0O,EAAGC,EAAGyM,EAAKC,EAAKC,EATvB,MAYR9b,EAAEN,EAAI,GAAKc,EACXR,EAAEN,EAAI,GAAKwP,EACXlP,EAAEN,EAAI,GAAKyP,EAEXnP,EAAEN,EAAI,GAAKc,EACXR,EAAEN,EAAI,GAAKwP,EACXlP,EAAEN,EAAI,GAAKyP,EAEXnP,EAAEN,EAAK+Z,GAAYjZ,EACnBR,EAAEN,GAAK+Z,EAAU,IAAMvK,EACvBlP,EAAEN,GAAK+Z,EAAU,IAAMtK,EAEvBnP,EAAEN,EAAK+Z,GAAYjZ,EACnBR,EAAEN,GAAK+Z,EAAU,IAAMvK,EACvBlP,EAAEN,GAAK+Z,EAAU,IAAMtK,EAEvBnP,EAAEN,GAAK+Z,EAAU,IAAMjZ,EACvBR,EAAEN,GAAK+Z,EAAU,IAAMvK,EACvBlP,EAAEN,GAAK+Z,EAAU,IAAMtK,EAEvBnP,EAAEN,GAAK+Z,EAAU,IAAMjZ,EACvBR,EAAEN,GAAK+Z,EAAU,IAAMvK,EACvBlP,EAAEN,GAAK+Z,EAAU,IAAMtK,EAEvBnP,EAAEN,GAAK+Z,EAAU,IAAMjZ,EACvBR,EAAEN,GAAK+Z,EAAU,IAAMvK,EACvBlP,EAAEN,GAAK+Z,EAAU,IAAMtK,EAEvBnP,EAAEN,GAAK+Z,EAAU,IAAMjZ,EACvBR,EAAEN,GAAK+Z,EAAU,IAAMvK,EACvBlP,EAAEN,GAAK+Z,EAAU,IAAMtK,IAInC,OAAOuJ,GASX7W,KAAK4a,OAAS,SAAU/D,GAUpB,IATA,IAAI1Y,EAAI0Y,EAAOlS,KACXiU,EAAO,IAAInF,kBAAkBtV,GAE7B8B,EAAQoB,EAAOhB,cAAciC,aAAa,SAC1CpC,EAASmB,EAAOhB,cAAciC,aAAa,UAE3CuY,EAAa,GACbC,EAAc,GAEX7a,EAAQ4a,GAAc,GACzBA,IACAC,IAKJ,IAAK,IAAIjd,EAAI,EAAGA,EAAIoC,EAAOpC,GAAKgd,EAC5B,IAAK,IAAI3J,EAAI,EAAGA,EAAIhR,EAAQgR,GAAK4J,EAS7B,IAJA,IAAInc,EAAIia,EAAK,EAAI/a,EAAI,EAAIqT,EAAIjR,GACzBoN,EAAIuL,EAAK,EAAI/a,EAAI,EAAIqT,EAAIjR,EAAQ,GACjCqN,EAAIsL,EAAK,EAAI/a,EAAI,EAAIqT,EAAIjR,EAAQ,GAE5BkR,EAAItT,EAAGsT,EAAItT,EAAIgd,EAAY1J,IAChC,IAAK,IAAIrT,EAAIoT,EAAGpT,EAAIoT,EAAI4J,EAAahd,IACjCK,EAAE,EAAIgT,EAAI,EAAIrT,EAAImC,GAAStB,EAC3BR,EAAE,EAAIgT,EAAI,EAAIrT,EAAImC,EAAQ,GAAKoN,EAC/BlP,EAAE,EAAIgT,EAAI,EAAIrT,EAAImC,EAAQ,GAAKqN,EAK/C,OAAOuJ,GAUX7W,KAAK+a,SAAW,SAAUlE,GAStB,IARA,IAAI1Y,EAAI0Y,EAAOlS,KACXiU,EAAO,IAAInF,kBAAkBtV,GAE7B8B,EAAQoB,EAAOhB,cAAciC,aAAa,SAC1CpC,EAASmB,EAAOhB,cAAciC,aAAa,UAC3CuY,EAAa,IACbC,EAAc,IAEX7a,EAAQ4a,GAAc,GACzBA,IACAC,IAEJ,IAAK,IAAIjd,EAAI,EAAGA,EAAIM,EAAE+F,OAAQrG,GAAkB,EAAbgd,EAC/B,IAAK,IAAI3J,EAAI,EAAGA,EAAIhR,EAAQgR,GAAK4J,EAK7B,IAHA,IAAInc,EAAIia,EAAK,EAAI/a,EAAIqT,GACjB7D,EAAIuL,EAAK,EAAI/a,EAAIqT,EAAI,GACrB5D,EAAIsL,EAAK,EAAI/a,EAAIqT,EAAI,GAChBC,EAAI,EAAItT,EAAGsT,EAAK,EAAItT,EAAM,EAAIgd,EAAa1J,GAAK,EACrD,IAAK,IAAIrT,EAAIoT,EAAGpT,EAAIoT,EAAI4J,EAAahd,IACjCK,EAAEgT,EAAIrT,GAAKa,EACXR,EAAEgT,EAAIrT,EAAI,GAAKuP,EACflP,EAAEgT,EAAIrT,EAAI,GAAKwP,EAK/B,OAAOuJ,GA0RX7W,KAAKgb,QAAU,SAAUnE,GAOrB,IANA,IAAIzU,EAAUf,EAAOhB,cAAc2B,WAAW,MAC1C/B,EAAQoB,EAAOhB,cAAciC,aAAa,SAC1CpC,EAASmB,EAAOhB,cAAciC,aAAa,UAE3CqC,GADUvC,EAAQqC,aAAa,EAAG,EAAGxE,EAAOC,GACrC2W,EAAOlS,MACdsW,EAAe,GACVpd,EAAI,EAAGA,EAAI8G,EAAKT,OAAQrG,GAAK,EAAG,CAGrC,IAAI0O,EAASjB,KAAKuB,MAAsB,GAAhBvB,KAAKmM,UACzByD,EAAO5P,KAAKmM,SAAW,GAAK,GAAK,EACjC0D,EAAK1F,EAAe5X,EAAGoC,EAAOC,GAClC,GAAIib,EAAGnV,EAAIsF,KAAKuB,MAAM5M,EAAQ,KAAQ,GAAKkb,EAAGlV,EAAIqF,KAAKuB,MAAM3M,EAAS,KAAQ,GAAc,IAATib,EAAGnV,EAAS,CAC3F,IAEIoV,EAAK,IAAIhG,EAFJ8F,EAAO3O,EAAU4O,EAAGnV,EACpBkV,EAAO3O,EAAU4O,EAAGlV,EACJtB,EAAK9G,GAAI8G,EAAK9G,EAAI,GAAI8G,EAAK9G,EAAI,IACxDod,EAAavZ,KAAK0Z,IAG1B,IAAIC,EAzLR,SAASC,EAAYC,EAAYC,GAC7B,IAEIjG,EAAkB,IAAZiG,EAAgB,IAAM,IAahC,GAZAD,EAAWE,MAAK,SAAUpP,EAAGiB,GACzB,OAAIjB,EAAEkJ,GAAOjI,EAAEiI,IACH,EAEHlJ,EAAEkJ,GAAOjI,EAAEiI,GACT,EAGA,KAIW,IAAtBgG,EAAWrX,OACX,OAAO,KAEX,GAA0B,IAAtBqX,EAAWrX,OACX,OAAO,IAAImR,EAAKkG,EAAW,GAAIC,GAEnC,GAA0B,IAAtBD,EAAWrX,OAAc,CAGzB,IAAIwX,EAAY,IAAIrG,EAAKkG,EAAW,GAAIC,GACpCG,EAAW,IAAItG,EAAKkG,EAAW,IAAKC,EAAU,GAzBzC,GA2BT,OADAE,EAAUla,KAAOma,EACVD,EAGX,IAAIE,EAAWtQ,KAAKuB,OAAO0O,EAAWrX,OAAS,GAAK,GAChD2X,EAAU,IAAIxG,EAAKkG,EAAWK,GAAWJ,GAG7C,OAFAK,EAAQra,KAAO8Z,EAAYC,EAAWO,MAAM,EAAGF,IAAYJ,EAAU,GAhCxD,GAiCbK,EAAQrG,MAAQ8F,EAAYC,EAAWO,MAAMF,EAAW,EAAGL,EAAWrX,SAAUsX,EAAU,GAjC7E,GAkCNK,EAsJMP,CAAYL,EAAc,GACvCvO,QAAQC,IAAI0O,GACZ,IAASxd,EAAI,EAAGA,EAAI8G,EAAKT,OAAQrG,GAAK,EAAG,CACrC,IAAIke,EAAatG,EAAe5X,EAAGoC,EAAOC,GACtCiW,EAAkBH,EAAoBqF,EAAQU,EAAW/V,EAAG+V,EAAW9V,GAe3EtB,EAAK9G,GAAKsY,EAAgBxX,EAC1BgG,EAAK9G,EAAI,GAAKsY,EAAgB9I,EAC9B1I,EAAK9G,EAAI,GAAKsY,EAAgB7I,EAElC,OAAOuJ,GAGX7W,KAAKgc,WAAa,SAAUnF,GACxB,IAAIzU,EAAUf,EAAOhB,cAAc2B,WAAW,MAC1C/B,EAAQoB,EAAOhB,cAAciC,aAAa,SAC1CpC,EAASmB,EAAOhB,cAAciC,aAAa,UAE3CqC,GADUvC,EAAQqC,aAAa,EAAG,EAAGxE,EAAOC,GACrC2W,EAAOlS,MACdsX,EAAkB,IAAIxI,kBAAkB9O,GAC5CkS,EAASvE,EAAKsE,UAAUC,GAGxB,IAFA,IAAIqF,EAAU,CAAC,EAAE,EAAG,EAAG,GAAI,EAAE,EAAG,EAAG,GAAI,EAAE,EAAG,EAAG,IAC3CC,EAAU,CAAC,EAAE,GAAI,GAAI,GAAI,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG,EAAG,IACtCte,EAAI,EAAGA,EAAIqC,EAAS,EAAGrC,IAC5B,IAAK,IAAIqT,EAAI,EAAGA,EAAI,EAAIjR,EAAQ,EAAGiR,GAAK,EAAG,CACvC,IAAI1P,EAAQ,EAAI3D,EAAIoC,GAAUiR,EAAI,GAC9BsE,EAAS,EAAI3X,EAAIoC,GAAUiR,EAAI,GAC/B5P,EAAO,GAAKzD,EAAI,GAAKoC,EAASiR,EAC9BkL,EAAU,GAAKve,EAAI,GAAKoC,EAASiR,EACjCmL,EAAW,GAAKxe,EAAI,GAAKoC,GAAUiR,EAAI,GACvCoL,EAAY,GAAKze,EAAI,GAAKoC,GAAUiR,EAAI,GACxCqL,EAAc,GAAK1e,EAAI,GAAKoC,GAAUiR,EAAI,GAC1CsL,EAAe,GAAK3e,EAAI,GAAKoC,GAAUiR,EAAI,GAC3CuL,EAAU,EAAIxc,EAAQpC,EAAKqT,EAE3BwL,EAAMR,EAAQ,GAAG,GAAKD,EAAgBI,GAAaH,EAAQ,GAAG,GAAKD,EAAgB3a,GAAS4a,EAAQ,GAAG,GAAKD,EAAgBK,GAC3HJ,EAAQ,GAAG,GAAKD,EAAgBza,GAAU0a,EAAQ,GAAG,GAAKD,EAAgBQ,GAAYP,EAAQ,GAAG,GAAKD,EAAgBzG,GACtH0G,EAAQ,GAAG,GAAKD,EAAgBM,GAAgBL,EAAQ,GAAG,GAAKD,EAAgBG,GAAYF,EAAQ,GAAG,GAAKD,EAAgBO,GAE7HG,EAAMR,EAAQ,GAAG,GAAKF,EAAgBI,GAAaF,EAAQ,GAAG,GAAKF,EAAgB3a,GAAS6a,EAAQ,GAAG,GAAKF,EAAgBK,GAC3HH,EAAQ,GAAG,GAAKF,EAAgBza,GAAU2a,EAAQ,GAAG,GAAKF,EAAgBQ,GAAYN,EAAQ,GAAG,GAAKF,EAAgBzG,GACtH2G,EAAQ,GAAG,GAAKF,EAAgBM,GAAgBJ,EAAQ,GAAG,GAAKF,EAAgBG,GAAYD,EAAQ,GAAG,GAAKF,EAAgBO,GAE7HI,EAAUtR,KAAKuR,KAAKvR,KAAKiI,KAAMmJ,EAAKA,EAAOC,EAAKA,IACpDhY,EAAK8X,GAAUG,EACfjY,EAAK8X,EAAS,GAAKG,EACnBjY,EAAK8X,EAAS,GAAKG,EACnBjY,EAAK8X,EAAS,GAAK,IAG3B,OAAO5F,GHl9BE,CAAYlW,EAAWkE,GAMxC,SAASiY,EAAYC,GACpB,IAAIC,EAAKpc,SAASO,eAAe4b,GAC7BE,EAAQD,EAAGE,SAAS,GACG,UAAxBD,EAAMjc,MAAMuC,QACd0Z,EAAMjc,MAAMuC,QAAU,SAEtB0Z,EAAMjc,MAAMuC,QAAU,OACtByZ,EAAGhc,MAAMmc,aAAgB,GAX3Bvc,SAASO,eAAe,gBAAgB2B,iBAAiB,SAAS,WAAYga,EAAY,cAC1Flc,SAASO,eAAe,eAAe2B,iBAAiB,SAAS,WAAYga,EAAY","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","// TODO: have an animation mode and a paint mode? in paint mode, you can do all the layering per frame and stuff.\r\n// in animation mode, we process all the frames and for each one condense all their layers into a single frame.\r\n// then we can use those frames in an animation.\r\n// to optimize performance when going into animation mode, maybe cache which frames are 'tainted' from the last time \r\n// animation mode was switched to.\r\n/***\r\n    super canvas class\r\n    the instance variables hold the default attributes for any canvas.\r\n    it also holds important information like a list of all the canvas instances.\r\n    setupNewCanvas should be used to create a new canvas instance\r\n    @param container = the parent element ID (i.e. of a div) to append the canvas elements to\r\n    \r\n    a supercanvas is really a frame, containing a list of canvas elements which represent layers of the frame\r\n***/\r\n\r\nfunction Frame(container, number) {\r\n    this.width = 800; // default value\r\n    this.height = 800;\r\n    this.currentIndex = 0;\r\n    this.canvasList = []; // keep a list of all canvas instances\r\n    this.currentCanvas; // the current, active canvas being looked at (reference to html element)\r\n    this.container = container; // this is the html container id to hold all the layers of this frame\r\n    this.tainted = false; // set to true if any layers are edited\r\n    this.number = number; // frame number\r\n    this.count = 0; // current number of layers\r\n    this.getMetadata = function () {\r\n        return {\r\n            'width': this.width,\r\n            'height': this.height,\r\n            'currentIndex': this.currentIndex,\r\n            'number': this.number\r\n        };\r\n    };\r\n    this.getCurrCanvas = function () {\r\n        return this.canvasList[this.currentIndex];\r\n    };\r\n    /***\r\n        set up a new canvas element\r\n        makes the new canvas the current canvas\r\n    ***/\r\n    this.setupNewLayer = function () {\r\n        // create the new canvas element \r\n        var newCanvas = document.createElement('canvas');\r\n        newCanvas.id = \"frame\" + this.number + \"canvas\" + this.count;\r\n        setCanvas(newCanvas, this.width, this.height);\r\n        if (this.count === 0) {\r\n            newCanvas.style.opacity = .97;\r\n            newCanvas.style.zIndex = 1;\r\n        }\r\n        // add it to the container passed in as the argument\r\n        document.getElementById(this.container).appendChild(newCanvas);\r\n        // set new canvas to be the current canvas only initially!\r\n        if (this.count === 0) {\r\n            this.currentCanvas = newCanvas;\r\n        }\r\n        // if at least 1 canvas already present, make the previous canvas be slightly opaque for onion-skin effect\r\n        if (this.count >= 1) {\r\n            // position the new canvas directly on top of the previous one \r\n            var canvas = document.getElementById(this.canvasList[0].id);\r\n            var top = canvas.offsetTop;\r\n            var left = canvas.offsetLeft;\r\n            newCanvas.style.top = top;\r\n            newCanvas.style.left = left;\r\n        }\r\n        this.canvasList.push(newCanvas);\r\n        this.count++;\r\n    };\r\n    this.hide = function () {\r\n        // puts all layers at zIndex -1 so they're not visible\r\n        this.canvasList.forEach(function (canvas) {\r\n            canvas.style.zIndex = -1;\r\n            canvas.style.visibility = 'hidden';\r\n        });\r\n    };\r\n    this.show = function () {\r\n        // makes all layers visible\r\n        this.canvasList.forEach(function (canvas) {\r\n            canvas.style.zIndex = 1;\r\n            canvas.style.visibility = '';\r\n        });\r\n    };\r\n    /***\r\n        clone the current canvas\r\n    ***/\r\n    this.copyCanvas = function () {\r\n        var newCanvas = document.createElement('canvas');\r\n        newCanvas.id = 'frame' + this.number + 'canvas' + this.count;\r\n        setCanvas(newCanvas, this.width, this.height);\r\n        this.canvasList[this.count - 1].style.opacity = .92;\r\n        // place the canvas in the container \r\n        document.getElementById(container).appendChild(newCanvas);\r\n        // position the new canvas directly on top of the previous one \r\n        var canvas = document.getElementById(this.canvasList[0].id);\r\n        var top = canvas.offsetTop;\r\n        var left = canvas.offsetLeft;\r\n        newCanvas.style.top = top;\r\n        newCanvas.style.left = left;\r\n        newCanvas.getContext(\"2d\").drawImage(this.currentCanvas, 0, 0);\r\n        this.canvasList.push(newCanvas);\r\n        this.count++;\r\n    };\r\n    this.clearCurrentLayer = function () {\r\n        var currLayer = this.getCurrCanvas();\r\n        var context = currLayer.getContext(\"2d\");\r\n        context.clearRect(0, 0, currLayer.getAttribute('width'), currLayer.getAttribute('height'));\r\n        context.fillStyle = \"#FFFFFF\";\r\n        context.fillRect(0, 0, currLayer.getAttribute('width'), currLayer.getAttribute('height'));\r\n    };\r\n    this.resetFrame = function () {\r\n    };\r\n}\r\n/***\r\n    an animation is a single project containing one or more supercanvases (or frames).\r\n    it also instantiates an onion skin frame.\r\n***/\r\nfunction AnimationProject(container) {\r\n    this.name = \"\";\r\n    this.currentFrame = 0; // should this be a ref to the current frame!?\r\n    this.speed = 100; // 100 ms per frame \r\n    this.frameList = [];\r\n    this.mode = 0; // 0 == drawing mode. 1 == animation mode.\r\n    this.onionSkinFrame = createOnionSkinFrame(container);\r\n    this.onionSkinFrame.style.display = 'none'; // hide it initially\r\n    this.container = container; // id of the html element the frames are displayed in\r\n    this.resetProject = function () {\r\n        this.frameList.forEach(function (frame, frameIndex) {\r\n            // remove each layer from the DOM \r\n            var parent = document.getElementById(frame['container']);\r\n            // just keep the first layer\r\n            frame.canvasList.forEach(function (layer, layerIndex) {\r\n                if (layerIndex > 0) {\r\n                    parent.removeChild(layer);\r\n                }\r\n            });\r\n            frame.canvasList = [frame.canvasList[0]];\r\n            if (frameIndex === 0) {\r\n                frame.currentIndex = 0;\r\n                frame.currentCanvas = frame.canvasList[0];\r\n            }\r\n        });\r\n        this.frameList = [this.frameList[0]]; // just keep the first frame.\r\n        // clear the first layer of the first frame!\r\n        this.frameList[0].clearCurrentLayer();\r\n        this.currentFrame = 0;\r\n        this.mode = 0;\r\n        this.speed = 100;\r\n    };\r\n    this.addNewFrame = function (showFlag) {\r\n        var newFrame = new Frame(this.container, this.frameList.length);\r\n        newFrame.setupNewLayer();\r\n        this.frameList.push(newFrame);\r\n        if (!showFlag) {\r\n            newFrame.hide();\r\n        }\r\n    };\r\n    this.nextFrame = function () {\r\n        if (this.frameList.length === this.currentFrame + 1) {\r\n            return null; // no more frames to see\r\n        }\r\n        this.currentFrame += 1;\r\n        return this.frameList[this.currentFrame];\r\n    };\r\n    this.prevFrame = function () {\r\n        if (this.currentFrame - 1 < 0) {\r\n            return null; // no more frames to see\r\n        }\r\n        this.currentFrame -= 1;\r\n        return this.frameList[this.currentFrame];\r\n    };\r\n    this.getCurrFrame = function () {\r\n        return this.frameList[this.currentFrame];\r\n    };\r\n    this.updateOnionSkin = function () {\r\n        if (this.currentFrame - 1 < 0) {\r\n            return;\r\n        }\r\n        // https://stackoverflow.com/questions/6787899/combining-two-or-more-canvas-elements-with-some-sort-of-blending\r\n        this.onionSkinFrame.style.display = ''; // show onion skin\r\n        var onionSkinCtx = this.onionSkinFrame.getContext(\"2d\");\r\n        onionSkinCtx.clearRect(0, 0, this.onionSkinFrame.width, this.onionSkinFrame.height);\r\n        // take the previous frame, merge all layers, put into onion skin frame\r\n        // try this? only draw pixels that are non-white?\r\n        var onionSkinImageData = onionSkinCtx.getImageData(0, 0, this.onionSkinFrame.width, this.onionSkinFrame.height);\r\n        // build the merged image from the first to last\r\n        var prevFrame = this.frameList[this.currentFrame - 1];\r\n        prevFrame.canvasList.forEach(function (layer) {\r\n            var imageData = layer.getContext(\"2d\").getImageData(0, 0, layer.width, layer.height).data;\r\n            for (var i = 0; i < imageData.length; i += 4) {\r\n                if (imageData[i] === 255 && imageData[i + 1] === 255 && imageData[i + 2] === 255) {\r\n                    continue;\r\n                }\r\n                else {\r\n                    // what if the canvas we're getting image data from to draw on the onion skin is LARGER than the onion skin canvas.\r\n                    // we might run into index/length issues...\r\n                    onionSkinImageData.data[i] = imageData[i];\r\n                    onionSkinImageData.data[i + 1] = imageData[i + 1];\r\n                    onionSkinImageData.data[i + 2] = imageData[i + 2];\r\n                    onionSkinImageData.data[i + 3] = 255;\r\n                }\r\n            }\r\n            // apply each layer to the onion skin\r\n            onionSkinCtx.putImageData(onionSkinImageData, 0, 0);\r\n        });\r\n        this.onionSkinFrame.style.zIndex = 0;\r\n        this.onionSkinFrame.style.opacity = 0.92;\r\n    };\r\n}\r\n\r\nfunction createOnionSkinFrame(container) {\r\n    var width = 800;\r\n    var height = 800;\r\n    // create the new canvas element \r\n    var newCanvas = document.createElement('canvas');\r\n    newCanvas.id = \"onionSkinCanvas\";\r\n    setCanvas(newCanvas, width, height);\r\n    newCanvas.style.opacity = .97;\r\n    newCanvas.style.zIndex = -1; // come back to this later. make sure it's visible if current frame > 1!\r\n    // add it to the container passed in as the argument\r\n    document.getElementById(container).appendChild(newCanvas);\r\n    return newCanvas;\r\n}\r\n// assigns position, z-index, border, width, height and opacity\r\nfunction setCanvas(canvasElement, width, height) {\r\n    canvasElement.style.position = 'absolute';\r\n    canvasElement.style.border = '1px #000 solid';\r\n    canvasElement.style.zIndex = 0;\r\n    canvasElement.style.opacity = 0;\r\n    canvasElement.setAttribute('width', width);\r\n    canvasElement.setAttribute('height', height);\r\n    canvasElement.getContext(\"2d\").fillStyle = \"rgba(255,255,255,255)\"; //\"#fff\";\r\n    canvasElement.getContext(\"2d\").fillRect(0, 0, width, height);\r\n}\r\n\r\nexport {\r\n\tFrame,\r\n\tAnimationProject,\r\n\tcreateOnionSkinFrame,\r\n\tsetCanvas\r\n};\r\n","import { Frame, AnimationProject } from './built/SuperCanvas.js';\r\nimport { Brush } from './built/Brush.js';\r\nimport { Filters } from './built/Filters.js';\r\nimport { Toolbar } from './built/Toolbar.js';\r\n\r\n// prevent FOUC\r\ndocument.addEventListener(\"DOMContentLoaded\", function(){\r\n\t$('html').css('display', 'block');\r\n});\r\n\r\n// set up project\r\nlet project = new AnimationProject('canvasArea');\r\nproject.addNewFrame(true); // since it's the first frame, show it\r\nlet newCanvas = project.getCurrFrame();\r\n\r\n// set up brush\r\nlet newBrush = new Brush(project);\r\nnewBrush.defaultBrush();\r\n\r\n// set up toolbar \r\n// here I'm passing in element Id's that these functions will attach to\r\nlet newToolbar = new Toolbar(newCanvas, newBrush, project);\r\nnewToolbar.setCounter(\"count\");\r\nnewToolbar.setKeyDown(document);\t// enables new canvas add on spacebar, go to next with right arrow, prev with left arrow.\r\nnewToolbar.createColorWheel('colorPicker', 200);\r\nnewToolbar.floodFill('floodfill');\r\nnewToolbar.insertLayer('insertCanvas');\r\nnewToolbar.deleteLayer('deleteCanvas', 'count');\r\nnewToolbar.setClearCanvas('clearCanvas');\r\nnewToolbar.rotateImage('rotateCanvasImage'); \r\nnewToolbar.undo('undo');\r\nnewToolbar.download('download');\r\nnewToolbar.importImage('importImage');\r\nnewToolbar.save('saveWork');\r\nnewToolbar.importProject('importProject', 'count');\r\nnewToolbar.addNewFrameButton('addNewFrame');\r\n\r\n// make the goLeft and goRight arrows clickable FOR LAYERS\r\n// note: this is for clicking the icons with a mouse!\r\ndocument.getElementById('goLeft').addEventListener('click', () => {\r\n\tif(newToolbar.down()){\r\n\t\tlet curr = project.getCurrFrame();\r\n\t\tdocument.getElementById(\"count\").textContent = \"frame: \" + (project.currentFrame+1) + \", layer: \" + (curr.currentIndex + 1);\r\n\t}\r\n});\r\n\r\ndocument.getElementById('goRight').addEventListener('click', () => {\r\n\tif(newToolbar.up()){\r\n\t\tlet curr = project.getCurrFrame();\r\n\t\tdocument.getElementById(\"count\").textContent = \"frame: \" + (project.currentFrame+1) + \", layer: \" + (curr.currentIndex + 1);\r\n\t}\r\n});\r\n\r\n// left and right arrows for FRAMES\r\ndocument.getElementById('prevFrame').addEventListener('click', () => {\r\n\tif(newToolbar.prevFrame()){\r\n\t\tlet curr = project.getCurrFrame();\r\n\t\tdocument.getElementById(\"count\").textContent = \"frame: \" + (project.currentFrame+1) + \", layer: \" + (curr.currentIndex + 1);\r\n\t}\r\n});\r\n\r\ndocument.getElementById('nextFrame').addEventListener('click', () => {\r\n\tif(newToolbar.nextFrame()){\r\n\t\tlet curr = project.getCurrFrame();\r\n\t\tdocument.getElementById(\"count\").textContent = \"frame: \" + (project.currentFrame+1) + \", layer: \" + (curr.currentIndex + 1);\r\n\t}\r\n});\r\n\r\ndocument.getElementById('generateGif').addEventListener('click', () => {\r\n\tnewToolbar.getGif(\"loadingScreen\");\r\n});\r\n\r\ndocument.getElementById('toggleLayerOrFrame').addEventListener('click', () => {\r\n\telement = document.getElementById(\"toggleLayerOrFrame\");\r\n\tif(newToolbar.layerMode){\r\n\t\tnewToolbar.layerMode = false;\r\n\t\telement.textContent = \"toggle layer addition on spacebar press\";\r\n\t}else{\r\n\t\tnewToolbar.layerMode = true;\r\n\t\telement.textContent = \"toggle frame addition on spacebar press\";\r\n\t}\r\n});\r\n\r\n// set up filters object\r\nlet newFilters = new Filters(newCanvas, newBrush);\r\n\r\ndocument.getElementById('filterSelect').addEventListener('click', function(){ showOptions('filters') });\r\ndocument.getElementById('brushSelect').addEventListener('click', function(){ showOptions('brushes') });\r\n\r\n// show options when clicking on filters or brushes \r\nfunction showOptions(category){\r\n\tlet el = document.getElementById(category);\r\n\tlet child = el.children[1]; // skip the p element and get the ul element\r\n\tif(child.style.display !== \"block\" ){\r\n\t\tchild.style.display = \"block\";\r\n\t}else{\r\n\t\tchild.style.display = \"none\";\r\n\t\tel.style.marginBottom  = 0;\r\n\t}\r\n}\r\n\r\n// update brush size display\r\nfunction showSize(){\r\n\tdocument.getElementById('brushSizeValue').textContent = document.getElementById('brushSize').value;\r\n}\r\n\r\n// show some samples/demos!!\r\nfunction getDemo(selected){\r\n\r\n\t// case for the blank option \r\n\tif(selected.options[selectedDemo.selectedIndex].text === \"\"){\r\n\t\treturn;\r\n\t}\r\n\r\n\t// get the selected demo from the dropbox\r\n\t// selectedDemo is the path to the demo to load \r\n\tlet selectedDemo = \"demos/\" + selected.options[selected.selectedIndex].text + \".json\"; \r\n\r\n\tlet httpRequest = new XMLHttpRequest();\r\n\r\n\tif(!httpRequest){\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t// set request type\r\n\thttpRequest.open(\"GET\", selectedDemo);\r\n\t\r\n\t// what to do when data comes back\r\n\thttpRequest.onload = function(){\r\n\t\t\r\n\t\t// parse the JSON using JSON.parse \r\n\t\tlet data = JSON.parse(httpRequest.responseText);\r\n\r\n\t\tif(!data[0] || (!data[0].name && !data[0].height && !data[0].width && !data[0].data)){\r\n\t\t\tconsole.log(\"it appears to not be a valid project! :<\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// clear existing project\r\n\t\tproject.resetProject();\r\n\t\t// update UI \r\n\t\tif(newToolbar.htmlCounter){\r\n\t\t\t// ideally if you use react or some library that can update the view based on the current state,\r\n\t\t\t// you shouldn't need this at all. hint hint.\r\n\t\t\tnewToolbar.htmlCounter.textContent = \"frame: \" + (project.currentFrame+1) + \", layer: \" + (project.frameList[project.currentFrame].currentIndex + 1);\r\n\t\t}\r\n\t\t\r\n\t\t// load saved project\r\n\t\tdata.forEach(function(frame, index){\r\n\t\t\tif(index > 0){\r\n\t\t\t\t// add a new frame\r\n\t\t\t\tproject.addNewFrame();\r\n\t\t\t}\r\n\t\t\t// overwrite existing frame\r\n\t\t\t// TODO: implement an updateFrame method \r\n\t\t\t// animationProj.updateFrame(0, frame); // updateFrame takes an index of the existing frame to overwrite and takes a SuperCanvas object to update with as well\r\n\t\t\tlet currFrame = project.frameList[index];\r\n\t\t\tconsole.log(\"need to add \" + frame.layers.length + \" layers for frame: \" + (index+1));\r\n\t\t\t\r\n\t\t\tlet currFrameLayersFromImport = frame.layers; // looking at data-to-import's curr frame's layers\r\n\t\t\tlet currFrameLayersFromCurrPrj = currFrame.canvasList;\r\n\t\t\tcurrFrameLayersFromImport.forEach(function(layer, layerIndex){\r\n\t\t\t\tif((layerIndex+1) > currFrameLayersFromCurrPrj.length){\r\n\t\t\t\t\t// add new layer to curr project as needed based on import\r\n\t\t\t\t\tconsole.log(\"need to add a new layer for frame: \" + index);\r\n\t\t\t\t\tproject.frameList[index].setupNewLayer();\r\n\t\t\t\t}\r\n\t\t\t\tlet currLayer = project.frameList[index].canvasList[layerIndex];\r\n\t\t\t\t\r\n\t\t\t\t// is this part necessary? maybe, if you want the project to look exactly as when it was saved.\r\n\t\t\t\tcurrLayer.style.opacity = layer.opacity;\r\n\t\t\t\tcurrLayer.style.zIndex = layer.zIndex;  \r\n\t\t\t\tcurrLayer.height = layer.height;\r\n\t\t\t\tcurrLayer.width = layer.width;\r\n\t\t\t\t\r\n\t\t\t\t// add the image data \r\n\t\t\t\tlet newCtx = currLayer.getContext(\"2d\");\r\n\t\t\t\tlet img = new Image();\r\n\t\t\t\t\r\n\t\t\t\t(function(context, image){\r\n\t\t\t\t\timage.onload = function(){\r\n\t\t\t\t\t\t\tcontext.drawImage(image, 0, 0);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\timage.src = layer.imageData;\r\n\t\t\t\t})(newCtx, img);\r\n\t\t\t\t\r\n\t\t\t});\r\n\t\t});\r\n\t\t\t\t\t\t\r\n\t}\r\n\t\r\n\t// send the request \r\n\thttpRequest.send();\r\n}\r\n","/***\r\n    brush class\r\n    pass in an instance of the SuperCanvas class as an argument\r\n    the canvas argument will have a reference to the current canvas so that\r\n    only the current canvas will be a target for the brush\r\n***/\r\nfunction Brush(animationProject) {\r\n    // pass in an animation project, from which you can access the current frame and the current canvas\r\n    this.previousCanvas = undefined;\r\n    this.currentCanvasSnapshots = []; // keep track of what the current canvas looks like after each mouseup\r\n    this.selectedBrush = 'default'; // user-selected brush \r\n    this.currColor = '#000';\r\n    this.currColorArray = Uint8Array.from([0, 0, 0, 0]);\r\n    this.currSize = 2;\r\n    // these variables keep track of the pixels drawn on by the mouse.\r\n    // the redraw function uses this data to connect the dots \r\n    var clickX = [];\r\n    var clickY = [];\r\n    var clickDrag = [];\r\n    var clickColor = [];\r\n    var clickSize = [];\r\n    // hold the current image after mouseup. \r\n    // only put it in the currentCanvasSnapshots after user starts drawing again, creating a new snapshot\r\n    var tempSnapshot;\r\n    // pass in an instance of the SuperCanvas class as an argument\r\n    // the canvas argument will have a reference to the current canvas so that\r\n    // only the current canvas will be a target for the brush\r\n    // note that a new variable, \"thisBrushInstance\", is assigned this (I want the brush object instance). \r\n    // that is because when you go inside another function (i.e. mousedown), \r\n    // using \"this\" doesn't refer to the object you're in, but that other function itself. \r\n    var thisBrushInstance = this;\r\n    this.changeBrushSize = function (size) {\r\n        this.currSize = size;\r\n    };\r\n    this.defaultBrush = function () {\r\n        // reset mouse action functions first \r\n        resetBrush();\r\n        var canvas = animationProject.getCurrFrame();\r\n        var paint;\r\n        $('#' + canvas.currentCanvas.id).on('mousedown touchstart', function (e) {\r\n            if ((e.which === 1 && e.type === 'mousedown') || e.type === 'touchstart') { //when left click only\r\n                // update previousCanvas\r\n                if (thisBrushInstance.previousCanvas !== canvas.currentCanvas) {\r\n                    thisBrushInstance.previousCanvas = canvas.currentCanvas;\r\n                    // reset the snapshots array\r\n                    thisBrushInstance.currentCanvasSnapshots = [];\r\n                }\r\n                if (tempSnapshot) {\r\n                    thisBrushInstance.currentCanvasSnapshots.push(tempSnapshot);\r\n                }\r\n                paint = true;\r\n                // offset will be different with mobile\r\n                // use e.originalEvent because using jQuery\r\n                // https://stackoverflow.com/questions/17130940/retrieve-the-same-offsetx-on-touch-like-mouse-event\r\n                // https://stackoverflow.com/questions/11287877/how-can-i-get-e-offsetx-on-mobile-ipad\r\n                // using rect seems to work pretty well\r\n                if (e.type === 'touchstart') {\r\n                    var rect = e.target.getBoundingClientRect();\r\n                    e.offsetX = e.originalEvent.touches[0].pageX - rect.left;\r\n                    e.offsetY = e.originalEvent.touches[0].pageY - rect.top;\r\n                }\r\n                addClick(e.offsetX, e.offsetY, true);\r\n                redraw(canvas);\r\n            }\r\n        });\r\n        //draw the lines as mouse moves\r\n        $('#' + canvas.currentCanvas.id).on('mousemove touchmove', function (e) {\r\n            if (paint) {\r\n                if (e.type === 'touchmove') {\r\n                    var rect = e.target.getBoundingClientRect();\r\n                    e.offsetX = e.originalEvent.touches[0].pageX - rect.left;\r\n                    e.offsetY = e.originalEvent.touches[0].pageY - rect.top;\r\n                    // prevent page scrolling when drawing \r\n                    e.preventDefault();\r\n                }\r\n                addClick(e.offsetX, e.offsetY, true);\r\n                redraw(canvas);\r\n            }\r\n        });\r\n        //stop drawing\r\n        $('#' + canvas.currentCanvas.id).on('mouseup touchend', function (e) {\r\n            // see if it's a new canvas or we're still on the same one as before the mousedown\r\n            if (thisBrushInstance.previousCanvas === canvas.currentCanvas) {\r\n                // if it is, then log the current image data. this is important for the undo feature\r\n                var c = canvas.currentCanvas;\r\n                var w = c.width;\r\n                var h = c.height;\r\n                tempSnapshot = canvas.currentCanvas.getContext(\"2d\").getImageData(0, 0, w, h);\r\n            }\r\n            clearClick();\r\n            paint = false;\r\n        });\r\n        //stop drawing when mouse leaves\r\n        $('#' + canvas.currentCanvas.id).mouseleave(function (e) {\r\n            paint = false;\r\n        });\r\n    };\r\n    /***\r\n        radial gradient brush\r\n    ***/\r\n    this.radialGradBrush = function () {\r\n        // reset mouse action functions first \r\n        resetBrush();\r\n        var canvas = animationProject.getCurrFrame();\r\n        var curCanvas = canvas.currentCanvas.id;\r\n        var context = canvas.currentCanvas.getContext(\"2d\");\r\n        var paint;\r\n        context.lineJoin = context.lineCap = 'round';\r\n        $('#' + curCanvas).mousedown(function (e) {\r\n            if (e.which === 1) {\r\n                paint = true;\r\n                radialGrad(e.offsetX, e.offsetY);\r\n            }\r\n        });\r\n        $('#' + curCanvas).mousemove(function (e) {\r\n            if (paint) {\r\n                radialGrad(e.offsetX, e.offsetY);\r\n            }\r\n        });\r\n        $('#' + curCanvas).mouseup(function (e) {\r\n            paint = false;\r\n            if (thisBrushInstance.previousCanvas === canvas.currentCanvas) {\r\n                // if it is, then log the current image data. this is important for the undo feature\r\n                var c = canvas.currentCanvas;\r\n                var w = c.width;\r\n                var h = c.height;\r\n                thisBrushInstance.currentCanvasSnapshots.push(canvas.currentCanvas.getContext(\"2d\").getImageData(0, 0, w, h));\r\n            }\r\n        });\r\n        //stop drawing when mouse leaves\r\n        $('#' + curCanvas).mouseleave(function (e) {\r\n            paint = false;\r\n        });\r\n    };\r\n    function radialGrad(x, y) {\r\n        var canvas = animationProject.getCurrFrame();\r\n        var context = canvas.currentCanvas.getContext(\"2d\");\r\n        var radGrad = context.createRadialGradient(x, y, thisBrushInstance.currSize, x, y, thisBrushInstance.currSize * 1.5);\r\n        var colorPicked = thisBrushInstance.currColorArray;\r\n        radGrad.addColorStop(0, thisBrushInstance.currColor);\r\n        if (colorPicked !== undefined) {\r\n            radGrad.addColorStop(.5, 'rgba(' + colorPicked[0] + ',' + colorPicked[1] + ',' + colorPicked[2] + ',.5)');\r\n            radGrad.addColorStop(1, 'rgba(' + colorPicked[0] + ',' + colorPicked[1] + ',' + colorPicked[2] + ',0)');\r\n        }\r\n        else {\r\n            radGrad.addColorStop(.5, 'rgba(0,0,0,.5)');\r\n            radGrad.addColorStop(1, 'rgba(0,0,0,0)');\r\n        }\r\n        context.fillStyle = radGrad;\r\n        context.fillRect(x - 20, y - 20, 40, 40);\r\n    }\r\n    function resetBrush() {\r\n        var canvas = animationProject.getCurrFrame();\r\n        var curCanvas = canvas.getCurrCanvas().id; //canvas.currentCanvas.id;\r\n        //detach any events from mouse actions (reset the events connected with mouse events)\r\n        $('#' + curCanvas).off(\"mousedown\");\r\n        $('#' + curCanvas).off(\"mouseup\");\r\n        $('#' + curCanvas).off(\"mousemove\");\r\n    }\r\n    //collect info where each pixel is to be drawn on canvas\r\n    function addClick(x, y, dragging) {\r\n        //var brushInstance = \r\n        clickX.push(x);\r\n        clickY.push(y);\r\n        clickDrag.push(dragging);\r\n        clickColor.push(thisBrushInstance.currColor);\r\n        clickSize.push(thisBrushInstance.currSize);\r\n    }\r\n    function redraw(canvas) {\r\n        var canvas = animationProject.getCurrFrame();\r\n        var context = canvas.currentCanvas.getContext(\"2d\");\r\n        context.lineJoin = 'round';\r\n        for (var i = 0; i < clickX.length; i++) {\r\n            context.beginPath();\r\n            //this helps generate a solid line, rather than a line of dots. \r\n            //the subtracting of 1 from i means that the point at i is being connected\r\n            //with the previous point\r\n            if (clickDrag[i] && i) {\r\n                context.moveTo(clickX[i - 1], clickY[i - 1]);\r\n            }\r\n            else {\r\n                //the adding of 1 allows you to make a dot on click\r\n                context.moveTo(clickX[i], clickY[i] + 1);\r\n            }\r\n            context.lineTo(clickX[i], clickY[i]);\r\n            context.closePath();\r\n            context.strokeStyle = clickColor[i];\r\n            context.lineWidth = clickSize[i];\r\n            context.stroke();\r\n        }\r\n    }\r\n    function clearClick() {\r\n        clickX = [];\r\n        clickY = [];\r\n        clickDrag = [];\r\n        clickColor = [];\r\n        clickSize = [];\r\n    }\r\n}\r\n\r\nexport {\r\n\tBrush\r\n};\r\n","// toolbar class\r\n// assemble the common functions for the toolbar\r\n// remove canvas param since you have animationProj\r\nfunction Toolbar(canvas, brush, animationProj) {\r\n    // keep this variable for storing the most recent imported image\r\n    // can be useful for resetting image\r\n    var recentImage;\r\n    // used as a counter for the animation playback features\r\n    var play = null;\r\n    // this will only work for the very first frame!!\r\n    // when each method is called, the current canvas needs to be recalculated\r\n    //var canvas = animationProj.frameList[animationProj.currentFrame];\r\n    // used to hold user-indicated time (ms) per frame for animation playback and gif\r\n    this.timePerFrame = 200; // set to 200 be default\r\n    // should the keyboard keys be affecting the layer or the frame? 2 options only\r\n    // this is useful for the arrow keys and space bar\r\n    this.layerMode = true;\r\n    this.htmlCounter = \"\"; // html element used as a counter specifying the current frame and layer\r\n    this.setCounter = function (elementId) {\r\n        this.htmlCounter = document.getElementById(elementId);\r\n    };\r\n    this.up = function () {\r\n        // this moves the current layer to the next one if exists\r\n        var canvas = animationProj.getCurrFrame();\r\n        if (canvas.currentIndex + 1 < canvas.canvasList.length) {\r\n            // move to next canvas\r\n            canvas.currentCanvas.style.opacity = .92; // apply onion skin to current canvas \r\n            canvas.currentCanvas.style.zIndex = 0;\r\n            // in the special case for when you want to go to the next canvas from the very first one, \r\n            // ignore the step where the opacity and z-index for the previous canvas get reset to 0.\r\n            if (canvas.currentIndex > 0) {\r\n                // reset opacity and z-index for previous canvas (because of onionskin)\r\n                canvas.canvasList[canvas.currentIndex - 1].style.opacity = 0;\r\n                canvas.canvasList[canvas.currentIndex - 1].style.zIndex = 0;\r\n            }\r\n            // show the next canvas \r\n            canvas.canvasList[canvas.currentIndex + 1].style.opacity = .97;\r\n            canvas.canvasList[canvas.currentIndex + 1].style.zIndex = 1;\r\n            canvas.currentCanvas = canvas.canvasList[canvas.currentIndex + 1];\r\n            canvas.currentIndex++;\r\n            // apply brush on new current canvas \r\n            brush.defaultBrush();\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    this.down = function () {\r\n        // this moves the current layer to the previous one if exists\r\n        var canvas = animationProj.getCurrFrame();\r\n        if (canvas.currentIndex - 1 >= 0) {\r\n            // move to previous canvas \r\n            // first make current canvas not visible anymore\r\n            canvas.currentCanvas.style.opacity = 0;\r\n            canvas.currentCanvas.style.zIndex = 0;\r\n            // make previous canvas visible \r\n            canvas.canvasList[canvas.currentIndex - 1].style.opacity = .97;\r\n            canvas.canvasList[canvas.currentIndex - 1].style.zIndex = 1;\r\n            // if there is another canvas before the previous one, apply onion skin\r\n            if (canvas.currentIndex - 2 >= 0) {\r\n                canvas.canvasList[canvas.currentIndex - 2].style.opacity = .92;\r\n            }\r\n            canvas.currentCanvas = canvas.canvasList[canvas.currentIndex - 1];\r\n            canvas.currentIndex--;\r\n            // apply brush\r\n            brush.defaultBrush();\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    this.nextFrame = function () {\r\n        var curr = animationProj.getCurrFrame();\r\n        var next = animationProj.nextFrame();\r\n        if (next !== null) {\r\n            curr.hide();\r\n            next.show();\r\n            animationProj.updateOnionSkin();\r\n            brush.defaultBrush();\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    this.prevFrame = function () {\r\n        var curr = animationProj.getCurrFrame();\r\n        var prev = animationProj.prevFrame();\r\n        if (prev !== null) {\r\n            curr.hide();\r\n            prev.show();\r\n            animationProj.updateOnionSkin();\r\n            brush.defaultBrush();\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    this.addPage = function () {\r\n        // TODO: shouldn't this be in Animation? \r\n        var canvas = animationProj.getCurrFrame();\r\n        canvas.setupNewLayer();\r\n    };\r\n    this.setKeyDown = function (doc) {\r\n        var toolbar = this;\r\n        var counterText = this.htmlCounter;\r\n        $(doc).keydown(function (e) {\r\n            var counterUpdateString = \"\";\r\n            switch (e.which) {\r\n                case 37: //left arrow key\r\n                    if (toolbar.down()) {\r\n                        var canvas = animationProj.getCurrFrame();\r\n                        counterUpdateString = \"frame: \" + (animationProj.currentFrame + 1) + \", layer: \" + (canvas.currentIndex + 1);\r\n                    }\r\n                    break;\r\n                case 39: //right arrow key\r\n                    if (toolbar.up()) {\r\n                        var canvas = animationProj.getCurrFrame();\r\n                        counterUpdateString = \"frame: \" + (animationProj.currentFrame + 1) + \", layer: \" + (canvas.currentIndex + 1);\r\n                    }\r\n                    break;\r\n                case 32: //space bar\r\n                    if (toolbar.layerMode) {\r\n                        toolbar.addPage();\r\n                    }\r\n                    else {\r\n                        animationProj.addNewFrame();\r\n                    }\r\n                    break;\r\n                case 65: // a key \r\n                    if (toolbar.prevFrame()) {\r\n                        var canvas = animationProj.getCurrFrame();\r\n                        counterUpdateString = \"frame: \" + (animationProj.currentFrame + 1) + \", layer: \" + (canvas.currentIndex + 1);\r\n                    }\r\n                    break;\r\n                case 68: // d key \r\n                    if (toolbar.nextFrame()) {\r\n                        var canvas = animationProj.getCurrFrame();\r\n                        counterUpdateString = \"frame: \" + (animationProj.currentFrame + 1) + \", layer: \" + (canvas.currentIndex + 1);\r\n                    }\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            if (toolbar.htmlCounter && counterUpdateString) {\r\n                counterText.textContent = counterUpdateString;\r\n            }\r\n            e.preventDefault();\r\n        });\r\n    };\r\n    /***\r\n        insert a frame after the current frame\r\n    ***/\r\n    this.insertLayer = function (elementId) {\r\n        // not sure if better idea to add the container the layers go in as an instance variable \r\n        // or pass in elementId here? \r\n        $('#' + elementId).click(function () {\r\n            var canvas = animationProj.getCurrFrame();\r\n            // add a new canvas first \r\n            canvas.setupNewLayer();\r\n            // then move it after the current canvas \r\n            var newestCanvas = canvas.canvasList.pop();\r\n            canvas.canvasList.splice(canvas.currentIndex + 1, 0, newestCanvas);\r\n        });\r\n    };\r\n    /***\r\n        delete current frame\r\n        shifts the current frame to the next one if there is one.\r\n        otherwise, the previous frame will become the current one.\r\n        if there isn't a previous one either, then the frame will just be made blank.\r\n    ***/\r\n    this.deleteLayer = function (elementId) {\r\n        // elementId here refers to the display that shows current frame and layer\r\n        var toolbarReference = this;\r\n        $('#' + elementId).click(function () {\r\n            var canvas = animationProj.getCurrFrame();\r\n            var oldCanvasIndex = canvas.currentIndex;\r\n            var oldCanvasId = canvas.currentCanvas.id;\r\n            var parentNode = document.getElementById(oldCanvasId).parentNode;\r\n            // if there's a canvas ahead of the current one \r\n            if (canvas.currentIndex + 1 < canvas.canvasList.length) {\r\n                // move current canvas to the next one \r\n                toolbarReference.up();\r\n                // remove the old canvas from the array and the DOM!\r\n                canvas.canvasList.splice(oldCanvasIndex, 1);\r\n                parentNode.removeChild(document.getElementById(oldCanvasId));\r\n                // adjust the current canvas index after the removal \r\n                canvas.currentIndex -= 1;\r\n            }\r\n            else if (canvas.currentIndex - 1 >= 0) {\r\n                // if there's a canvas behind the current one (and no more ahead)\r\n                // move current canvas to the previous one \r\n                // note that currentIndex doesn't need to be adjusted because removing the \r\n                // next canvas doesn't affect the current canvas' index\r\n                toolbarReference.down();\r\n                canvas.canvasList.splice(oldCanvasIndex, 1);\r\n                parentNode.removeChild(document.getElementById(oldCanvasId));\r\n                // but need to adjust the counter, if present\r\n                if (toolbarReference.htmlCounter) {\r\n                    toolbarReference.htmlCounter.textContent = \"frame: \" + (animationProj.currentFrame + 1) + \", layer:\" + (canvas.currentIndex + 1);\r\n                }\r\n            }\r\n            else {\r\n                // otherwise, just blank the canvas \r\n                var context = canvas.currentCanvas.getContext(\"2d\");\r\n                context.clearRect(0, 0, canvas.currentCanvas.getAttribute('width'), canvas.currentCanvas.getAttribute('height'));\r\n                context.fillStyle = \"#fff\";\r\n                context.fillRect(0, 0, canvas.currentCanvas.getAttribute('width'), canvas.currentCanvas.getAttribute('height'));\r\n            }\r\n        });\r\n    };\r\n    /***\r\n        add a new frame\r\n        note that it's adding a supercanvas instance\r\n    ***/\r\n    this.addNewFrameButton = function (elementId) {\r\n        $('#' + elementId).click(function () {\r\n            animationProj.addNewFrame();\r\n        });\r\n    };\r\n    /***\r\n        color wheel functions\r\n    ***/\r\n    // pass in the elementId of the div where the color wheel should be \r\n    // pass in the size of the canvas of the color wheel \r\n    this.createColorWheel = function (elementId, size) {\r\n        var location = document.getElementById(elementId);\r\n        var colorWheel = document.createElement('canvas');\r\n        colorWheel.id = \"colorWheel\";\r\n        colorWheel.setAttribute('width', size);\r\n        colorWheel.setAttribute('height', size);\r\n        var colorWheelContext = colorWheel.getContext('2d');\r\n        var x = colorWheel.width / 2;\r\n        var y = colorWheel.height / 2;\r\n        var radius = 90;\r\n        // why 5600??\r\n        for (var angle = 0; angle <= 5600; angle++) {\r\n            var startAngle = (angle - 2) * Math.PI / 180; //convert angles to radians\r\n            var endAngle = (angle) * Math.PI / 180;\r\n            colorWheelContext.beginPath();\r\n            colorWheelContext.moveTo(x, y);\r\n            //.arc(x, y, radius, startAngle, endAngle, anticlockwise)\r\n            colorWheelContext.arc(x, y, radius, startAngle, endAngle, false);\r\n            colorWheelContext.closePath();\r\n            //use .createRadialGradient to get a different color for each angle\r\n            //createRadialGradient(x0, y0, r0, x1, y1, r1)\r\n            var gradient = colorWheelContext.createRadialGradient(x, y, 0, startAngle, endAngle, radius);\r\n            gradient.addColorStop(0, 'hsla(' + angle + ', 10%, 100%, 1)');\r\n            gradient.addColorStop(1, 'hsla(' + angle + ', 100%, 50%, 1)');\r\n            colorWheelContext.fillStyle = gradient;\r\n            colorWheelContext.fill();\r\n        }\r\n        // make black a pickable color \r\n        colorWheelContext.fillStyle = \"#000\";\r\n        colorWheelContext.fillRect(0, 0, 8, 8);\r\n        // make white pickable too \r\n        colorWheelContext.fillRect(10, 0, 8, 8); // border around the white \r\n        colorWheelContext.fillStyle = \"#fff\";\r\n        colorWheelContext.fillRect(11, 0, 6, 7);\r\n        location.appendChild(colorWheel);\r\n        // make the color wheel interactive and show picked color \r\n        var showColor = document.createElement('p'); // this element will show the color picked \r\n        showColor.style.textAlign = 'center';\r\n        showColor.id = 'colorPicked';\r\n        showColor.textContent = \"pick a color! :)\";\r\n        location.appendChild(showColor);\r\n        $('#' + colorWheel.id).mousedown(function (e) {\r\n            var x = e.offsetX;\r\n            var y = e.offsetY;\r\n            var colorPicked = (document.getElementById(colorWheel.id).getContext('2d')).getImageData(x, y, 1, 1).data;\r\n            var colorPickedText = document.getElementById(showColor.id);\r\n            //correct the font color if the color is really dark\r\n            if (colorPicked[0] > 10 && colorPicked[1] > 200) {\r\n                $('#' + showColor.id).css(\"color\", \"#000\");\r\n            }\r\n            else {\r\n                $('#' + showColor.id).css(\"color\", \"#FFF\");\r\n            }\r\n            colorPickedText.textContent = 'rgb(' + colorPicked[0] + ',' + colorPicked[1] + ',' + colorPicked[2] + ')';\r\n            $('#' + showColor.id).css({ 'background-color': colorPickedText.textContent });\r\n            // update current color seleted in brush object as Uint8 clamped array where each index corresponds to r,g,b,a\r\n            brush.currColorArray = colorPicked;\r\n            brush.currColor = 'rgb(' + colorPicked[0] + ',' + colorPicked[1] + ',' + colorPicked[2] + ')';\r\n        });\r\n    };\r\n    /***\r\n    \r\n        attach floodfill function!\r\n    \r\n        still a bit slow. also, maybe instead of matching only exact color,\r\n        how about +/- 5 for r,g,b?\r\n        \r\n        also, maybe disable drawing? what if someone has the radial brush on\r\n        and they want to floodfill? it should operate normally in that case too.\r\n        might have to turn off the brush temporarily, then reconnect it?\r\n    \r\n    ***/\r\n    this.floodFill = function (elementId) {\r\n        $('#' + elementId).click(function () {\r\n            var canvas = animationProj.getCurrFrame();\r\n            var doFloodFill = function (e) {\r\n                // this is the color to change to!\r\n                // need to parse the currColor because right now it looks like \"rgb(x,y,z)\". \r\n                // I want it to look like [x, y, z]\r\n                var currColor = brush.currColor;\r\n                var currColorArray = currColor.substring(currColor.indexOf('(') + 1, currColor.length - 1).split(',');\r\n                currColorArray = currColorArray.map(function (a) { return parseInt(a); });\r\n                // get the coordinates of the selected pixel \r\n                var x = e.pageX - $('#' + canvas.currentCanvas.id).offset().left;\r\n                var y = e.pageY - $('#' + canvas.currentCanvas.id).offset().top;\r\n                //console.log(\"x: \" + x + \", y: \" + y);\r\n                var colorData = document.getElementById(canvas.currentCanvas.id).getContext(\"2d\").getImageData(x, y, 1, 1).data;\r\n                var color = 'rgb(' + colorData[0] + ',' + colorData[1] + ',' + colorData[2] + ')';\r\n                console.log(color);\r\n                // create an object with the pixel data\r\n                var pixel = { 'x': Math.floor(x), 'y': Math.floor(y), 'color': color };\r\n                // call the floodfill function!\r\n                // currentCanvas is a canvas element\r\n                floodfill(canvas.currentCanvas, currColorArray, pixel);\r\n                // remove event listener \r\n                canvas.currentCanvas.removeEventListener('click', doFloodFill);\r\n            };\r\n            canvas.currentCanvas.addEventListener('click', doFloodFill);\r\n        });\r\n    };\r\n    // the actual floodfill function \r\n    function floodfill(currentCanvas, newColor, pixelSelected) {\r\n        // create a stack \r\n        var stack = [];\r\n        // create visited set \r\n        // the format of these entries will be like: {'xCoord,yCoord': 1}\r\n        var visited = {};\r\n        // the selectedPixel will have the color that needs to be targeted by floodfill \r\n        var targetColor = pixelSelected.color;\r\n        // current canvas context \r\n        var ctx = document.getElementById(currentCanvas.id).getContext('2d');\r\n        // get the image data of the entire canvas \r\n        // do the floodfill, then put the edited image data back \r\n        var imageData = ctx.getImageData(0, 0, currentCanvas.width, currentCanvas.height);\r\n        var data = imageData.data;\r\n        stack.push(pixelSelected);\r\n        while (stack.length !== 0) {\r\n            // get a pixel\r\n            var currPixel = stack.pop();\r\n            // add to visited set \r\n            visited[currPixel.x + ',' + currPixel.y] = 1;\r\n            // get left, right, top and bottom neighbors \r\n            var leftNeighborX = currPixel.x - 1;\r\n            var rightNeighborX = currPixel.x + 1;\r\n            var topNeighborY = currPixel.y - 1;\r\n            var bottomNeighborY = currPixel.y + 1;\r\n            var r, g, b;\r\n            // top neighbor\r\n            if (topNeighborY >= 0 && visited[currPixel.x + ',' + topNeighborY] === undefined) {\r\n                // index of r, g and b colors in imageData.data\r\n                r = (topNeighborY * currentCanvas.width) * 4 + ((currPixel.x + 1) * 4);\r\n                g = r + 1;\r\n                b = g + 1;\r\n                if (targetColor === 'rgb(' + data[r] + ',' + data[g] + ',' + data[b] + ')') {\r\n                    // if the neighbor's color is the same as the targetColor, add it to the stack\r\n                    stack.push({ 'x': currPixel.x, 'y': topNeighborY, 'color': currPixel.color });\r\n                }\r\n            }\r\n            // right neighbor \r\n            if (rightNeighborX < currentCanvas.width && visited[rightNeighborX + ',' + currPixel.y] === undefined) {\r\n                r = (currPixel.y * currentCanvas.width) * 4 + ((rightNeighborX + 1) * 4);\r\n                g = r + 1;\r\n                b = g + 1;\r\n                if (targetColor === 'rgb(' + data[r] + ',' + data[g] + ',' + data[b] + ')') {\r\n                    // if the neighbor's color is the same as the targetColor, add it to the stack\r\n                    stack.push({ 'x': rightNeighborX, 'y': currPixel.y, 'color': currPixel.color });\r\n                }\r\n            }\r\n            // bottom neighbor\r\n            if (bottomNeighborY < currentCanvas.height && visited[currPixel.x + ',' + bottomNeighborY] === undefined) {\r\n                r = (bottomNeighborY * currentCanvas.width) * 4 + ((currPixel.x + 1) * 4);\r\n                g = r + 1;\r\n                b = g + 1;\r\n                if (targetColor === 'rgb(' + data[r] + ',' + data[g] + ',' + data[b] + ')') {\r\n                    // if the neighbor's color is the same as the targetColor, add it to the stack\r\n                    stack.push({ 'x': currPixel.x, 'y': bottomNeighborY, 'color': currPixel.color });\r\n                }\r\n            }\r\n            // left neighbor\r\n            if (leftNeighborX >= 0 && visited[leftNeighborX + ',' + currPixel.y] === undefined) {\r\n                r = (currPixel.y * currentCanvas.width) * 4 + ((leftNeighborX + 1) * 4);\r\n                g = r + 1;\r\n                b = g + 1;\r\n                if (targetColor === 'rgb(' + data[r] + ',' + data[g] + ',' + data[b] + ')') {\r\n                    // if the neighbor's color is the same as the targetColor, add it to the stack\r\n                    stack.push({ 'x': leftNeighborX, 'y': currPixel.y, 'color': currPixel.color });\r\n                }\r\n            }\r\n            // finally, update the color of the current pixel \r\n            r = (currPixel.y * currentCanvas.width) * 4 + ((currPixel.x + 1) * 4);\r\n            g = r + 1;\r\n            b = g + 1;\r\n            data[r] = newColor[0];\r\n            data[g] = newColor[1];\r\n            data[b] = newColor[2];\r\n        }\r\n        // put new edited image back on canvas \r\n        ctx.putImageData(imageData, 0, 0);\r\n    }\r\n    /***\r\n        rotate image\r\n        pass in an element id that will rotate the current canvas image on click\r\n        \r\n        currently buggy! after rotation, image becomes blurred. also, when attempting to draw on same canvas,\r\n        coordinates get altered so on mousedown the drawing gets offset\r\n    ***/\r\n    this.rotateImage = function (elementId) {\r\n        //rotate image\r\n        $('#' + elementId).click(function () {\r\n            var canvas = animationProj.getCurrFrame();\r\n            //using a promise to convert the initial image to a bitmap\r\n            var width = canvas.currentCanvas.getAttribute(\"width\");\r\n            var height = canvas.currentCanvas.getAttribute(\"height\");\r\n            var context = canvas.currentCanvas.getContext(\"2d\");\r\n            Promise.all([\r\n                createImageBitmap(canvas.currentCanvas, 0, 0, width, height)\r\n            ]).then(function (bitmap) {\r\n                context.clearRect(0, 0, width, height);\r\n                context.translate(width / 2, height / 2);\r\n                context.rotate((Math.PI) / 180);\r\n                context.translate(-width / 2, -height / 2);\r\n                //the returned bitmap is an array\r\n                context.drawImage(bitmap[0], 0, 0);\r\n            });\r\n        });\r\n    };\r\n    /***\r\n        clear the current canvas\r\n        pass in an element id that will execute clear canvas onclick\r\n    ***/\r\n    this.setClearCanvas = function (elementId) {\r\n        $('#' + elementId).click(function () {\r\n            var canvas = animationProj.getCurrFrame();\r\n            var context = canvas.currentCanvas.getContext(\"2d\");\r\n            context.clearRect(0, 0, canvas.currentCanvas.getAttribute('width'), canvas.currentCanvas.getAttribute('height'));\r\n            context.fillStyle = \"#FFFFFF\";\r\n            context.fillRect(0, 0, canvas.currentCanvas.getAttribute('width'), canvas.currentCanvas.getAttribute('height'));\r\n        });\r\n    };\r\n    /***\r\n        undo a previous drawing operation on the current canvas.\r\n        still a little incorrect?\r\n    ***/\r\n    this.undo = function (elementId) {\r\n        $('#' + elementId).click(function () {\r\n            var canvas = animationProj.getCurrFrame();\r\n            var context = canvas.currentCanvas.getContext(\"2d\");\r\n            var width = canvas.currentCanvas.getAttribute(\"width\");\r\n            var height = canvas.currentCanvas.getAttribute(\"height\");\r\n            // unshift to add to front of stack of snapshots. \r\n            brush.currentCanvasSnapshots.unshift(context.getImageData(0, 0, width, height));\r\n            // clear first\r\n            context.clearRect(0, 0, width, height);\r\n            // then put back last image (ignore the one that had just been drawn)\r\n            // snapshots is a temp variable that only holds all the images up to the 2nd to last image drawn. \r\n            // if you keep up to the last image drawn, then you have to click undo twice initially to get to the previous frame.\r\n            if (brush.currentCanvasSnapshots.length >= 1) {\r\n                var mostRecentImage = brush.currentCanvasSnapshots.pop();\r\n                context.putImageData(mostRecentImage, 0, 0);\r\n            }\r\n        });\r\n    };\r\n    /***\r\n        import an image\r\n    ***/\r\n    this.importImage = function (elementId) {\r\n        $('#' + elementId).click(function () {\r\n            var canvas = animationProj.getCurrFrame();\r\n            // call fileHandler here\r\n            fileHandler();\r\n            // define fileHandler \r\n            function fileHandler() {\r\n                //initiate file choosing after button click\r\n                var input = document.createElement('input');\r\n                input.type = 'file';\r\n                input.addEventListener('change', getFile, false);\r\n                input.click();\r\n            }\r\n            function getFile(e) {\r\n                var img = new Image();\r\n                var reader = new FileReader();\r\n                var file = e.target.files[0];\r\n                if (!file.type.match(/image.*/)) {\r\n                    console.log(\"not a valid image\");\r\n                    return;\r\n                }\r\n                //when the image loads, put it on the canvas.\r\n                img.onload = function () {\r\n                    // change current canvas' width and height according to imported picture\r\n                    // to keep proportion \r\n                    // i.e. if width is at least 100px more than height, scale the current canvas'\r\n                    // height back by multiplying .9 to 800. \r\n                    var currentCanvas = canvas.currentCanvas;\r\n                    var context = currentCanvas.getContext(\"2d\");\r\n                    var height = img.height;\r\n                    var width = img.width;\r\n                    if ((img.width - img.height) >= 100) {\r\n                        // if image is wider than it is tall\r\n                        currentCanvas.setAttribute('height', Math.floor(800 * .9));\r\n                        currentCanvas.setAttribute('width', Math.floor(800 * 1.1));\r\n                        height = currentCanvas.height;\r\n                        width = currentCanvas.width;\r\n                    }\r\n                    else if ((img.height - img.width) >= 200) {\r\n                        // if image is taller than it is wide\r\n                        currentCanvas.setAttribute('width', Math.floor(800 * .9));\r\n                        currentCanvas.setAttribute('height', Math.floor(800 * 1.1));\r\n                        height = currentCanvas.height;\r\n                        width = currentCanvas.width;\r\n                    }\r\n                    else {\r\n                        // default value in super canvas object\r\n                        height = canvas.height;\r\n                        width = canvas.width;\r\n                        currentCanvas.setAttribute('height', height);\r\n                        currentCanvas.setAttribute('width', width);\r\n                    }\r\n                    context.drawImage(img, 0, 0, width, height);\r\n                    // assign recentImage variable the image \r\n                    recentImage = img;\r\n                    // add the current image to snapshots \r\n                    brush.currentCanvasSnapshots.push(context.getImageData(0, 0, width, height));\r\n                };\r\n                //after reader has loaded file, put the data in the image object.\r\n                reader.onloadend = function () {\r\n                    img.src = reader.result;\r\n                };\r\n                //read the file as a URL\r\n                reader.readAsDataURL(file);\r\n            }\r\n        });\r\n    };\r\n    /***\r\n        reset the canvas to most recent imported image\r\n    ***/\r\n    this.resetImage = function () {\r\n        if (recentImage) {\r\n            var canvas = animationProj.getCurrFrame();\r\n            var context = canvas.currentCanvas.getContext(\"2d\");\r\n            var height = canvas.currentCanvas.getAttribute(\"height\");\r\n            var width = canvas.currentCanvas.getAttribute(\"width\");\r\n            context.drawImage(recentImage, 0, 0, width, height);\r\n        }\r\n    };\r\n    /***\r\n        download a png file of the current canvas\r\n    ***/\r\n    this.download = function (elementId) {\r\n        $('#' + elementId).click(function () {\r\n            // get image data from current canvas as blob\r\n            var data = document.getElementById(canvas.currentCanvas.id).toBlob(function (blob) {\r\n                var url = URL.createObjectURL(blob);\r\n                var link = document.createElement('a');\r\n                link.href = url;\r\n                var name = prompt(\"please enter a name for the file\");\r\n                if (name === null) {\r\n                    return;\r\n                }\r\n                else {\r\n                    link.download = name;\r\n                    //simulate a click on the blob's url to download it \r\n                    link.click();\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /********\r\n    \r\n        this section controls the animation playback features\r\n        \r\n        note that I specifically added my page counter element to the\r\n        functions so that they change with the call to up() and down()\r\n\r\n        this will need to be applied for FRAMES, not LAYERS of a frame.\r\n    \r\n    *********/\r\n    var toolbar = this;\r\n    var playFor = function () {\r\n        if (toolbar.nextFrame()) {\r\n            if (toolbar.htmlCounter) {\r\n                var counterText = toolbar.htmlCounter;\r\n                counterText.textContent = \"frame: \" + (animationProj.currentFrame + 1) + \", layer: \" + (canvas.currentIndex + 1);\r\n            }\r\n        }\r\n    };\r\n    var playBack = function () {\r\n        if (toolbar.prevFrame()) {\r\n            if (toolbar.htmlCounter) {\r\n                var counterText = toolbar.htmlCounter;\r\n                counterText.textContent = \"frame: \" + (animationProj.currentFrame + 1) + \", layer: \" + (canvas.currentIndex + 1);\r\n            }\r\n        }\r\n    };\r\n    this.playForward = function () {\r\n        clearInterval(play);\r\n        play = null;\r\n        play = setInterval(playFor, this.timePerFrame);\r\n    };\r\n    this.playBackward = function () {\r\n        clearInterval(play);\r\n        play = null;\r\n        //canvas.currentCanvas = canvas.canvasList[canvas.canvasList.length - 1];\r\n        //canvas.currentCanvas.style.zIndex = 1;\r\n        //canvas.currentCanvas.style.opacity = .97;\r\n        play = setInterval(playBack, this.timePerFrame);\r\n    };\r\n    this.stop = function () {\r\n        clearInterval(play);\r\n        play = null;\r\n    };\r\n    /***\r\n    \r\n        create a gif from the frames.\r\n        using gif.js - https://github.com/jnordberg/gif.js\r\n    \r\n        elementId is for the loading message,\r\n        i.e. a <p> element that says \"now loading...\"\r\n        \r\n        this will need to be applied for FRAMES, not LAYERS of a frame.\r\n    \r\n    ***/\r\n    this.getGif = function (elementId) {\r\n        if (elementId) {\r\n            document.getElementById(elementId).textContent = \"now loading...\";\r\n        }\r\n        var gif = new GIF({\r\n            workers: 2,\r\n            quality: 10\r\n        });\r\n        // add frames\t\t\r\n        for (var i = 0; i < animationProj.frameList.length; i++) {\r\n            var tempCanvas = document.createElement('canvas');\r\n            tempCanvas.width = 800; // don't hardcode dimensions :<\r\n            tempCanvas.height = 800;\r\n            var tempCtx = tempCanvas.getContext(\"2d\");\r\n            tempCtx.fillStyle = \"white\";\r\n            tempCtx.fillRect(0, 0, 800, 800);\r\n            var tempImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);\r\n            var currFrame = animationProj.frameList[i];\r\n            for (var j = 0; j < currFrame.canvasList.length; j++) {\r\n                var layer = currFrame.canvasList[j];\r\n                var imageData = layer.getContext(\"2d\").getImageData(0, 0, layer.width, layer.height).data;\r\n                for (var k = 0; k < imageData.length; k += 4) {\r\n                    if (imageData[k] === 255 && imageData[k + 1] === 255 && imageData[k + 2] === 255) {\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        // what if the canvas we're getting image data from to draw on the onion skin is LARGER than the onion skin canvas.\r\n                        // we might run into index/length issues...\r\n                        tempImageData.data[k] = imageData[k];\r\n                        tempImageData.data[k + 1] = imageData[k + 1];\r\n                        tempImageData.data[k + 2] = imageData[k + 2];\r\n                        tempImageData.data[k + 3] = 255;\r\n                    }\r\n                }\r\n                // apply each layer to the onion skin\r\n                tempCtx.putImageData(tempImageData, 0, 0);\r\n            }\r\n            // TODO: make sure to merge all the layers for each frame!\r\n            gif.addFrame(tempCanvas, { delay: this.timePerFrame });\r\n        }\r\n        gif.on('finished', function (blob) {\r\n            document.getElementById(elementId).textContent = \"\";\r\n            var newGif = URL.createObjectURL(blob);\r\n            window.open(newGif);\r\n        });\r\n        gif.render();\r\n    };\r\n    /***\r\n    \r\n        save/export & import functions\r\n        check this out: https://stackoverflow.com/questions/22329481/compressing-base64-data-uri-images\r\n        \r\n        don't think this is going to work without some sort of better compression. simply drawing a few lines on\r\n        a canvas produces a very large base64 string spanning many lines. not very practical for exporting a project\r\n        that has several frames, especially if you take into account different colors and more detail\r\n        \r\n    ***/\r\n    this.save = function (elementId) {\r\n        $('#' + elementId).click(function () {\r\n            // prompt the user to name the file \r\n            var name = prompt(\"name of file: \");\r\n            if (name === \"\") {\r\n                name = \"funSketch_saveFile\";\r\n            }\r\n            else if (name === null) {\r\n                return;\r\n            }\r\n            var savedData = [];\r\n            animationProj.frameList.forEach(function (frame) {\r\n                // get frame metadata\r\n                var newFrame = frame.getMetadata();\r\n                newFrame['layers'] = []; // list of objects\r\n                frame.canvasList.forEach(function (layer) {\r\n                    // get layer metadata\r\n                    var newLayer = {\r\n                        'id': layer.id,\r\n                        'width': layer.getAttribute(\"height\"),\r\n                        'height': layer.getAttribute(\"width\"),\r\n                        'zIndex': layer.style.zIndex,\r\n                        'opacity': layer.style.opacity,\r\n                    };\r\n                    // add layer image data\r\n                    newLayer['imageData'] = layer.toDataURL();\r\n                    newFrame.layers.push(newLayer);\r\n                });\r\n                savedData.push(JSON.stringify(newFrame));\r\n            });\r\n            var json = \"[\\n\";\r\n            json += savedData.join(\",\\n\"); // put a line break between each new object, which represents a frame\r\n            json += \"\\n]\";\r\n            // make a blob so it can be downloaded \r\n            var blob = new Blob([json], { type: \"application/json\" });\r\n            var url = URL.createObjectURL(blob);\r\n            var link = document.createElement('a');\r\n            link.href = url;\r\n            link.download = name + \".json\";\r\n            link.click();\r\n        });\r\n    };\r\n    this.importProject = function (elementId, counterId) {\r\n        var self = this;\r\n        $('#' + elementId).click(function () {\r\n            fileHandler();\r\n            //import project json file\r\n            function fileHandler() {\r\n                var input = document.createElement('input');\r\n                input.type = 'file';\r\n                input.addEventListener('change', getFile, false);\r\n                input.click();\r\n            }\r\n            function getFile(e) {\r\n                var reader = new FileReader();\r\n                var file = e.target.files[0];\r\n                //when the file loads, put it on the canvas.\r\n                reader.onload = (function (theFile) {\r\n                    return function (e) {\r\n                        // parse the JSON using JSON.parse \r\n                        // check if it can be parsed though first!\r\n                        var data;\r\n                        try {\r\n                            data = JSON.parse(e.target.result);\r\n                        }\r\n                        catch (e) {\r\n                            // not valid json file \r\n                            return;\r\n                        }\r\n                        // do some validation\r\n                        // if there is no canvas\r\n                        // or it's a valid json object but no fields correspond to a canvas, quit\r\n                        if (!data[0] || (!data[0].name && !data[0].height && !data[0].width && !data[0].data)) {\r\n                            console.log(\"it appears to not be a valid project! :<\");\r\n                            return;\r\n                        }\r\n                        // clear existing project\r\n                        animationProj.resetProject();\r\n                        // update UI \r\n                        if (self.htmlCounter) {\r\n                            // ideally if you use react or some library that can update the view based on the current state,\r\n                            // you shouldn't need this at all. hint hint.\r\n                            self.htmlCounter.textContent = \"frame: \" + (animationProj.currentFrame + 1) + \", layer: \" + (canvas.currentIndex + 1);\r\n                        }\r\n                        // load saved project\r\n                        data.forEach(function (frame, index) {\r\n                            if (index > 0) {\r\n                                // add a new frame\r\n                                animationProj.addNewFrame();\r\n                            }\r\n                            // overwrite existing frame\r\n                            // TODO: implement an updateFrame method \r\n                            // animationProj.updateFrame(0, frame); // updateFrame takes an index of the existing frame to overwrite and takes a SuperCanvas object to update with as well\r\n                            var currFrame = animationProj.frameList[index];\r\n                            console.log(\"need to add \" + frame.layers.length + \" layers for frame: \" + (index + 1));\r\n                            var currFrameLayersFromImport = frame.layers; // looking at data-to-import's curr frame's layers\r\n                            var currFrameLayersFromCurrPrj = currFrame.canvasList;\r\n                            currFrameLayersFromImport.forEach(function (layer, layerIndex) {\r\n                                if ((layerIndex + 1) > currFrameLayersFromCurrPrj.length) {\r\n                                    // add new layer to curr project as needed based on import\r\n                                    console.log(\"need to add a new layer for frame: \" + index);\r\n                                    animationProj.frameList[index].setupNewLayer();\r\n                                }\r\n                                var currLayer = animationProj.frameList[index].canvasList[layerIndex];\r\n                                // is this part necessary? maybe, if you want the project to look exactly as when it was saved.\r\n                                currLayer.style.opacity = layer.opacity;\r\n                                currLayer.style.zIndex = layer.zIndex;\r\n                                currLayer.height = layer.height;\r\n                                currLayer.width = layer.width;\r\n                                // add the image data \r\n                                var newCtx = currLayer.getContext(\"2d\");\r\n                                var img = new Image();\r\n                                (function (context, image) {\r\n                                    image.onload = function () {\r\n                                        context.drawImage(image, 0, 0);\r\n                                    };\r\n                                    image.src = layer.imageData;\r\n                                })(newCtx, img);\r\n                            });\r\n                        });\r\n                    };\r\n                })(file);\r\n                reader.readAsText(file);\r\n            }\r\n        });\r\n    };\r\n} // end of Toolbar \r\n\r\n\r\nexport {\r\n\tToolbar\r\n};","//library for filters\r\n//reference: http://www.storminthecastle.com/2013/04/06/how-you-can-do-cool-image-effects-using-html5-canvas/\r\n// pass it an instance of super canvas and an instance of Brush\r\nfunction Filters(canvas, brush) {\r\n    var tempImage; // only push current image to snapshots if a tempImage exists already.\r\n    // this way when undo is called the image being looked at by the user won't already be saved in snapshots,\r\n    // and so undo wouldn't need to be clicked twice to see the last saved image. a bit confusing. :/\r\n    var self = this;\r\n    //general filtering function. pass any kind of filter through this function.\r\n    this.filterCanvas = function (filter) {\r\n        var context = canvas.currentCanvas.getContext(\"2d\");\r\n        var width = canvas.currentCanvas.getAttribute('width');\r\n        var height = canvas.currentCanvas.getAttribute('height');\r\n        var imgData = context.getImageData(0, 0, width, height);\r\n        // save current image to snapshots stack\r\n        if (tempImage) {\r\n            brush.currentCanvasSnapshots.push(tempImage);\r\n        }\r\n        filter(imgData);\r\n        context.putImageData(imgData, 0, 0);\r\n        tempImage = imgData;\r\n    };\r\n    // use this for select/option elements when picking a filter\r\n    this.filterCanvasOption = function (option) {\r\n        this.filterCanvas(this[option]);\r\n    };\r\n    /***\r\n        GRAYSCALE FILTER\r\n    ***/\r\n    //grayscale filter using an arithmetic average of the color components\r\n    //the 'pixels' parameter will be the imgData variable. \r\n    this.grayscale = function (pixels) {\r\n        var d = pixels.data;\r\n        for (var i = 0; i < d.length; i += 4) {\r\n            var r = d[i];\r\n            var g = d[i + 1];\r\n            var b = d[i + 2];\r\n            //the value obtained by (r+g+b)/3 will be the value assigned to d[i], d[i+1], and d[i+2].  \r\n            d[i] = d[i + 1] = d[i + 2] = (r + g + b) / 3;\r\n        }\r\n        return pixels;\r\n    };\r\n    /***\r\n        sepia filter\r\n    ***/\r\n    this.sepia = function (pixels) {\r\n        var d = pixels.data;\r\n        for (var i = 0; i < d.length; i += 4) {\r\n            var r = d[i];\r\n            var g = d[i + 1];\r\n            var b = d[i + 2];\r\n            d[i] = (r * .5) + (g * .2) + (b * .3); //red\r\n            d[i + 1] = (r * .2) + (g * .3) + (b * .5); //green\r\n            d[i + 2] = (r * .6) + (g * .3) + (b * .4); //blue\r\n        }\r\n        return pixels;\r\n    };\r\n    /***\r\n        SATURATION FILTER\r\n        source: http://www.qoncious.com/questions/changing-saturation-image-html5-canvas-using-javascript\r\n    ***/\r\n    this.saturate = function (pixels) {\r\n        var saturationValue = 2.5;\r\n        var d = pixels.data;\r\n        var lumR = .3086; //constant for determining luminance of red\r\n        var lumG = .6094; //constant for determining luminance of green\r\n        var lumB = .0820; //constant for determining luminance of blue\r\n        //one of these equations per r,g,b\r\n        var r1 = (1 - saturationValue) * lumR + saturationValue;\r\n        var g1 = (1 - saturationValue) * lumG + saturationValue;\r\n        var b1 = (1 - saturationValue) * lumB + saturationValue;\r\n        //then one of these for each\r\n        var r2 = (1 - saturationValue) * lumR;\r\n        var g2 = (1 - saturationValue) * lumG;\r\n        var b2 = (1 - saturationValue) * lumB;\r\n        for (var i = 0; i < d.length; i += 4) {\r\n            var r = d[i];\r\n            var g = d[i + 1];\r\n            var b = d[i + 2];\r\n            d[i] = r * r1 + g * g2 + b * b2;\r\n            d[i + 1] = r * r2 + g * g1 + b * b2;\r\n            d[i + 2] = r * r2 + g * g2 + b * b1;\r\n        }\r\n        return pixels;\r\n    };\r\n    /***\r\n        COLOR SWAP FILTER\r\n        this function swaps colors\r\n    ***/\r\n    this.swap = function (pixels) {\r\n        var d = pixels.data;\r\n        for (var i = 0; i < d.length; i += 4) {\r\n            var r = d[i];\r\n            var g = d[i + 1];\r\n            var b = d[i + 2];\r\n            d[i] = b;\r\n            d[i + 1] = r;\r\n            d[i + 2] = g;\r\n        }\r\n        return pixels;\r\n    };\r\n    /***\r\n        BANDED FILTER\r\n        this function creates bands\r\n    ***/\r\n    this.banded = function (pixels) {\r\n        var d = pixels.data;\r\n        for (var i = 0; i < d.length; i += 12) {\r\n            var r = d[i];\r\n            var g = d[i + 1];\r\n            var b = d[i + 2];\r\n            d[i] = \"#FFFFFF\";\r\n            d[i + 1] = \"#FFFFFF\";\r\n            d[i + 2] = \"#FFFFFF\";\r\n        }\r\n    };\r\n    /***\r\n        PURPLE CHROME FILTER\r\n        this function creates a light purplish 'chrome' effect\r\n        hmm, seemed to stop working after adjusting canvas to 800x800 from 700x700\r\n    ***/\r\n    this.purpleChrome = function (pixels) {\r\n        var d = pixels.data;\r\n        for (var i = 0; i < d.length; i++) {\r\n            var r = d[i];\r\n            var g = d[i + 1];\r\n            var b = d[i + 2];\r\n            d[i + 1] = b;\r\n            d[i + 2] = g;\r\n            d[i] = r;\r\n        }\r\n        return pixels;\r\n    };\r\n    /***\r\n        PURPLIZER\r\n        this filter turns any white spots purple\r\n    ***/\r\n    this.purplizer = function (pixels) {\r\n        //aka purplefier - all pixels with green=red or green>red become purple\r\n        var d = pixels.data;\r\n        for (var i = 0; i < d.length; i += 4) {\r\n            var r = d[i];\r\n            var g = d[i + 1];\r\n            var b = d[i + 2];\r\n            var a = d[i + 3];\r\n            if (g >= r) {\r\n                d[i + 2] = d[i + 2] * 2;\r\n                d[i + 1] = d[i + 2] / 2;\r\n            }\r\n        }\r\n        return pixels;\r\n    };\r\n    /***\r\n        SCARY(?) FILTER\r\n        this filter turns everything dark\r\n    ***/\r\n    this.scary = function (pixels) {\r\n        var saturationValue = 2.5;\r\n        var d = pixels.data;\r\n        //making the lumR,G,andB values nearly the same is equivalent to blacking out the picture i.e. 255,255,255 = black\r\n        var lumR = .6020; //constant for determining luminance of red\r\n        var lumG = .6094; //constant for determining luminance of green\r\n        var lumB = .6086; ////constant for determining luminance of blue\r\n        //one of these equations per r,g,b\r\n        var r1 = (1 - saturationValue) * lumR + saturationValue;\r\n        var g1 = (1 - saturationValue) * lumG + saturationValue;\r\n        var b1 = (1 - saturationValue) * lumB + saturationValue;\r\n        //then one of these for each\r\n        var r2 = (1 - saturationValue) * lumR;\r\n        var g2 = (1 - saturationValue) * lumG;\r\n        var b2 = (1 - saturationValue) * lumB;\r\n        for (var i = 0; i < d.length; i += 4) {\r\n            var r = d[i];\r\n            var g = d[i + 1];\r\n            var b = d[i + 2];\r\n            d[i] = r * r1 + g * g2 + b * b2;\r\n            d[i + 1] = r * r2 + g * g1 + b * b2;\r\n            d[i + 2] = r * r2 + g * g2 + b * b1;\r\n        }\r\n        return pixels;\r\n    };\r\n    /***\r\n        'HEATWAVE' FILTER\r\n        this filter saturates and darkens some colors and produces an interesting palette\r\n    ***/\r\n    this.heatwave = function (pixels) {\r\n        var d = pixels.data;\r\n        for (var i = 0; i < d.length; i++) {\r\n            var r = d[i];\r\n            var g = d[i + 1];\r\n            var b = d[i + 2];\r\n            if (g > 100 && g < 200) {\r\n                d[i + 1] = 0;\r\n            }\r\n            if (r < 100) {\r\n                d[i] = d[i] * 2;\r\n            }\r\n        }\r\n        return pixels;\r\n    };\r\n    /***\r\n        NOISE FILTER\r\n        I think this function should have been called 'noise'. it pretty much just shifts all the pixels around.\r\n    ***/\r\n    this.randomize = function (pixels) {\r\n        var d = pixels.data;\r\n        for (var i = 0; i < d.length; i += 4) {\r\n            var rand = Math.floor(Math.random() * 5 + 1); //random from 1 to 5\r\n            var r = d[i];\r\n            var g = d[i + 1];\r\n            var b = d[i + 2];\r\n            var a = d[i + 3];\r\n            //if there is a pixel that is not white (not 255,255,255)\r\n            if (r !== 255 || g !== 255 || b !== 255) {\r\n                //then move the pixel in a random direction (up, down, left, or right)\r\n                //depending on the random number\r\n                //1 = up, 2 = down, 3 = left, 4 = right, 5 = no movement\r\n                switch (rand) {\r\n                    case 1:\r\n                        if (i <= 2400) {\r\n                            //move down\r\n                            d[i + 2400] = r;\r\n                            d[i + 2401] = g;\r\n                            d[i + 2402] = b;\r\n                            d[i + 2403] = a;\r\n                        }\r\n                        else {\r\n                            d[i - 2403] = r;\r\n                            d[i - 2402] = g;\r\n                            d[i - 2401] = b;\r\n                            d[i - 2400] = a;\r\n                        }\r\n                        break;\r\n                    case 2:\r\n                        //move down \r\n                        d[i + 2400] = r;\r\n                        d[i + 2401] = g;\r\n                        d[i + 2402] = b;\r\n                        d[i + 2403] = a;\r\n                        break;\r\n                    case 3:\r\n                        d[i - 4] = r;\r\n                        d[i - 3] = g;\r\n                        d[i - 2] = b;\r\n                        d[i - 1] = a;\r\n                        break;\r\n                    case 4:\r\n                        d[i + 4] = r;\r\n                        d[i + 5] = g;\r\n                        d[i + 6] = b;\r\n                        d[i + 7] = a;\r\n                        break;\r\n                    case 5:\r\n                        //do nothing\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        return pixels;\r\n    };\r\n    /***\r\n        COLOR INVERTER\r\n        this function inverts colors\r\n    ***/\r\n    this.invert = function (pixels) {\r\n        var d = pixels.data;\r\n        var r, g, b, x, y, z;\r\n        for (var i = 0; i < d.length; i += 4) {\r\n            r = d[i];\r\n            g = d[i + 1];\r\n            b = d[i + 2];\r\n            d[i] = 255 - r;\r\n            d[i + 1] = 255 - g;\r\n            d[i + 2] = 255 - b;\r\n        }\r\n        return pixels;\r\n    };\r\n    /***\r\n        BLUR FILTER\r\n        this function causes a blurring effect. It takes the pixel itself and\r\n        its left, right, above and below neighbors (if it has them)\r\n        and calculates the average of their total R, G, B, and A channels respectively.\r\n        http://blog.ivank.net/fastest-gaussian-blur.html\r\n    ***/\r\n    this.blurry = function (pixels) {\r\n        var d = pixels.data;\r\n        var width = canvas.currentCanvas.getAttribute('width');\r\n        var maximum = 4 * width;\r\n        for (i = 0; i < d.length; i += 4) {\r\n            //if these conditions are not undefined, then that pixel must exist.\r\n            //right pixel (check if 4 pixel radius ok)\r\n            //also, the 2800 comes from the width and height of my canvas being 700, multiplied by 4.\r\n            var cond1 = (d[i + 4] == undefined);\r\n            //left pixel\r\n            var cond2 = (d[i - 4] == undefined);\r\n            //pixel below\r\n            var cond3 = (d[i + (maximum)] == undefined);\r\n            //pixel above\r\n            var cond4 = (d[i - (maximum)] == undefined);\r\n            if (!cond1 && !cond2 && !cond3 && !cond4) {\r\n                var newR = (d[i + 4] * .2 + d[i - 4] * .2 + d[i + (maximum)] * .2 + d[i - (maximum)] * .2 + d[i] * .2);\r\n                var newG = (d[i + 5] * .2 + d[i - 3] * .2 + d[i + (maximum + 1)] * .2 + d[i - (maximum - 1)] * .2 + d[i + 1] * .2);\r\n                var newB = (d[i + 6] * .2 + d[i - 2] * .2 + d[i + (maximum + 2)] * .2 + d[i - (maximum - 2)] * .2 + d[i + 2] * .2);\r\n                var newA = (d[i + 7] * .2 + d[i - 1] * .2 + d[i + (maximum + 3)] * .2 + d[i - (maximum - 3)] * .2 + d[i + 3] * .2);\r\n                d[i] = newR;\r\n                d[i + 1] = newG;\r\n                d[i + 2] = newB;\r\n                d[i + 3] = newA;\r\n            }\r\n        }\r\n        return pixels;\r\n    };\r\n    /***\r\n        OUTLINE FILTER\r\n        gets the 'outline' of the main parts of the picture\r\n        it finds the pixels whose above neighbor is a different color/\r\n        then a line is drawn from the location of that pixel to the above pixel,\r\n        forming a small, slightly angled line. all these lines then make up an outline.\r\n    ***/\r\n    this.outline = function () {\r\n        var width = canvas.currentCanvas.getAttribute('width');\r\n        var height = canvas.currentCanvas.getAttribute('height');\r\n        var context = canvas.currentCanvas.getContext(\"2d\");\r\n        var imgData = context.getImageData(0, 0, width, height);\r\n        var d = imgData.data;\r\n        var colCounter = 0;\r\n        var rowCounter = 0;\r\n        var count = 0;\r\n        var maximum = 4 * width;\r\n        context.clearRect(0, 0, width, height);\r\n        context.fillStyle = \"#FFF\";\r\n        context.fillRect(0, 0, width, height);\r\n        for (var i = 0; i < d.length; i += 4) {\r\n            var r = d[i];\r\n            var g = d[i + 1];\r\n            var b = d[i + 2];\r\n            context.lineJoin = 'round';\r\n            context.lineWidth = 2;\r\n            var tnr = d[i - (maximum)];\r\n            var tng = d[i - (maximum - 1)];\r\n            var tnb = d[i - (maximum - 2)];\r\n            //withinRange function is defined with the FISHEYE function\r\n            if (d[i - (maximum)] !== undefined && !withinRange(r, g, b, tnr, tng, tnb, 5)) {\r\n                if (count < 100) {\r\n                    count++;\r\n                }\r\n                makePath(colCounter, rowCounter);\r\n            }\r\n            if (i % (maximum) == 0) {\r\n                rowCounter++;\r\n            }\r\n            if (colCounter >= width) {\r\n                colCounter = 0;\r\n            }\r\n            colCounter++;\r\n        }\r\n    };\r\n    function makePath(col, row) {\r\n        var context = canvas.currentCanvas.getContext(\"2d\");\r\n        context.lineJoin = 'round';\r\n        context.lineWidth = 5;\r\n        context.beginPath();\r\n        context.moveTo(col, row);\r\n        context.lineTo(col + 2, row + 1);\r\n        context.closePath();\r\n        context.strokeStyle = '#000';\r\n        context.stroke();\r\n    }\r\n    /***\r\n        FISHEYE DISTORTION FILTER\r\n        this function creates fisheye distortion!\r\n        source: http://popscan.blogspot.com/2012/04/fisheye-lens-equation-simple-fisheye.html\r\n        http://paulbourke.net/dome/fisheye/\r\n    ***/\r\n    function fisheye(imgData, xPos, yPos, rad) {\r\n        //this is the array you edit with the translated pixels\r\n        var data = imgData.data;\r\n        var height = Math.sqrt(data.length / 4);\r\n        var width = Math.sqrt(data.length / 4);\r\n        //this is the original data set you want to refer to\r\n        //to put the correctly colored pixels in the right place\r\n        //remember to make a deep copy so that any editing to 'data' will not\r\n        //alter the elements in this array!\r\n        var oldData = new Uint8ClampedArray(data);\r\n        var pixelCounter = 0;\r\n        //rows\r\n        for (var y = 0; y < height; y++) {\r\n            //normalize y coordinate to -1...+1\r\n            var normY = (2 * y) / (height) - 1;\r\n            //calculate normY squared\r\n            var normY2 = normY * normY;\r\n            //columns\r\n            for (var x = 0; x < width; x++) {\r\n                //this counter will make sure that \r\n                //the right index for each pixel's color is\r\n                //being looked at \r\n                var start = pixelCounter * 4;\r\n                //normalize x coordinate to -1...+1\r\n                var normX = (2 * x) / (width) - 1;\r\n                //calculate normX squared\r\n                var normX2 = normX * normX;\r\n                //calculate distance from center (the center is always 0,0)\r\n                var dist = Math.sqrt(normX2 + normY2);\r\n                //only alter pixels inside of radius\r\n                //changing the dist range affects the scope of the lens. i.e. less range (.5 => .6) gives you a 'telescoping' lens. \r\n                //a larger range (0 => 1) gives you a full circle.\r\n                if ((0 <= dist) && (dist <= 1)) {\r\n                    var newR = Math.sqrt(1 - dist * dist);\r\n                    //new distance between 0 and 1\r\n                    newR = (dist + (1 - newR)) / 2;\r\n                    //discard any radius greater than 1\r\n                    if (newR <= 1) {\r\n                        //calculate angle for polar coordinates\r\n                        var theta = Math.atan2(normY, normX);\r\n                        //calculate new X position with new distance in same angle\r\n                        var newX = newR * Math.cos(theta);\r\n                        //calculate new Y position with new distance in same angle\r\n                        var newY = newR * Math.sin(theta);\r\n                        //get the location of where the pixels should be moved FROM.\r\n                        var x2 = Math.floor(((newX + 1) * (width)) / 2);\r\n                        var y2 = Math.floor(((newY + 1) * (height)) / 2);\r\n                        srcPos = ((width) * (y2)) + x2;\r\n                        srcPos *= 4;\r\n                        data[start] = oldData[srcPos];\r\n                        data[start + 1] = oldData[srcPos + 1];\r\n                        data[start + 2] = oldData[srcPos + 2];\r\n                        data[start + 3] = oldData[srcPos + 3];\r\n                    }\r\n                }\r\n                pixelCounter++;\r\n            } //end inner for loop\r\n        } //end outer for loop\r\n        var curContext = canvas.currentCanvas.getContext(\"2d\");\r\n        //yPos and xPos are the coordinates of the center of the area of interest\r\n        curContext.putImageData(imgData, xPos - rad, yPos - rad);\r\n    }\r\n    //the above function can be used like so below:\r\n    //first, a default fisheye that encompasses the canvas:\r\n    this.defaultFisheye = function () {\r\n        var width = canvas.currentCanvas.getAttribute('width');\r\n        var height = canvas.currentCanvas.getAttribute('height');\r\n        // temporary stop - figure out how to make this work for uneven dimensions!!\r\n        if (width !== height) {\r\n            return;\r\n        }\r\n        var context = canvas.currentCanvas.getContext(\"2d\");\r\n        var data = context.getImageData(0, 0, width, height);\r\n        fisheye(data, 0, 0, 0);\r\n    };\r\n    //this one is a mobile one, in which the user should be able to specify a \r\n    //a radius and can click anywhere on the canvas to generate a fisheye distortion within the \r\n    //specified radius.\r\n    //It works by making a new image data array with only the pixels from the area specified by the user (after an image has been imported),\r\n    //doing the distortion function on that array, and then putting the results in the same location it came from onto the canvas.\r\n    function mobileFisheye(radius, xPos, yPos) {\r\n        //xPos and yPos are the coordinates of the center of the area of interest\r\n        var diameter = radius * 2;\r\n        //xPos-radius = the x coordinate of the upper left corner of the area of interest!\r\n        var data = context.getImageData(xPos - radius, yPos - radius, diameter, diameter);\r\n        fisheye(data, xPos, yPos, radius);\r\n    }\r\n    /**** END FISHEYE *****/\r\n    /***\r\n\r\n        AREA COLOR (more like 'painter?')\r\n\r\n        the idea is to find an area of pixels that are similarly colored,\r\n        and then making that area one solid color\r\n        it also tends to remove dark outlines so that there aren't any\r\n        distinct boundaries\r\n        it is supposed to give a sort of 'painted' look to it.\r\n        still not perfect right now, but it's definitely in the right direction\r\n\r\n    ***/\r\n    //helper function\r\n    //this function is also used for the OUTLINE filter\r\n    function withinRange(r, g, b, or, og, ob, rangeVal) {\r\n        var red = Math.abs(r - or) <= rangeVal;\r\n        var green = Math.abs(g - og) <= rangeVal;\r\n        var blue = Math.abs(b - ob) <= rangeVal;\r\n        if (red && green && blue) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    //the idea is to find an area of pixels that are similarly colored, \r\n    //and then making that area one solid color\r\n    this.areaColor = function (pixels) {\r\n        var width = canvas.currentCanvas.getAttribute('width');\r\n        var d = pixels.data;\r\n        var copy = new Uint8ClampedArray(d);\r\n        var maximum = 4 * width;\r\n        for (var i = 0; i < d.length; i += 4) {\r\n            //current pixel\r\n            var r = d[i];\r\n            var g = d[i + 1];\r\n            var b = d[i + 2];\r\n            //left neighbor's color\r\n            var lnr = copy[i - 4];\r\n            var lng = copy[i - 3];\r\n            var lnb = copy[i - 2];\r\n            //right neighbor's color\r\n            var rnr = copy[i + 4];\r\n            var rng = copy[i + 5];\r\n            var rnb = copy[i + 6];\r\n            //top neighbor's color\r\n            var tnr = copy[i - (maximum)];\r\n            var tng = copy[i - (maximum - 1)];\r\n            var tnb = copy[i - (maximum - 2)];\r\n            //bottom neighbor's color\r\n            var bnr = copy[i + (maximum)];\r\n            var bng = copy[i + (maximum + 1)];\r\n            var bnb = copy[i + (maximum + 2)];\r\n            //top right\r\n            var trr = copy[i - (maximum - 4)];\r\n            var trg = copy[i - (maximum - 5)];\r\n            var trb = copy[i - (maximum - 6)];\r\n            //top left\r\n            var tlr = copy[i - (maximum + 4)];\r\n            var tlg = copy[i - (maximum + 3)];\r\n            var tlb = copy[i - (maximum + 2)];\r\n            //below left\r\n            var blr = copy[i + (maximum - 4)];\r\n            var blg = copy[i + (maximum - 3)];\r\n            var blb = copy[i + (maximum - 2)];\r\n            //below right\r\n            var brr = copy[i + (maximum + 4)];\r\n            var brg = copy[i + (maximum + 5)];\r\n            var brb = copy[i + (maximum + 6)];\r\n            //right pixel\r\n            var cond1 = (d[i + 4] === undefined);\r\n            //left pixel\r\n            var cond2 = (d[i - 4] === undefined);\r\n            //pixel below\r\n            var cond3 = (d[i + (maximum)] === undefined);\r\n            //pixel above\r\n            var cond4 = (d[i - (maximum)] === undefined);\r\n            //top left\r\n            var cond5 = (d[i - (maximum + 4)] === undefined);\r\n            //top right\r\n            var cond6 = (d[i - (maximum - 4)] === undefined);\r\n            //below right\r\n            var cond7 = (d[i + (maximum + 4)] === undefined);\r\n            //below left\r\n            var cond8 = (d[i + (maximum - 4)] === undefined);\r\n            if (!cond1 && !cond2 && !cond3 && !cond4 && !cond5 && !cond6 && !cond7 && !cond8) {\r\n                //if next neighbor over is a completely different color, stop and move on\r\n                var nnr = copy[i + 8];\r\n                var nng = copy[i + 9];\r\n                var nnb = copy[i + 10];\r\n                //next neighbor over (top right)\r\n                //using the current data, instead of the copy which holds the original color data,\r\n                //seems to provide closer to my desired effect\r\n                var trrr = d[i - (maximum - 8)];\r\n                var trrg = d[i - (maximum - 9)];\r\n                var trrb = d[i - (maximum - 10)];\r\n                /*\r\n                //next neighbor over (bottom right)\r\n                var brrr = d[i+2808];\r\n                var brrg = d[i+2809];\r\n                var brrb = d[i+2810];\r\n                */\r\n                if (!withinRange(r, g, b, nnr, nng, nnb, 18) ||\r\n                    !withinRange(r, g, b, trrr, trrg, trrb, 16) ||\r\n                    //!withinRange(r, g, b, brrr, brrg, brrb, 15)||\r\n                    (rnr >= 210 && rng >= 210 && rnb >= 200)) {\r\n                    continue;\r\n                }\r\n                var range = 50;\r\n                //check neighbors' colors\r\n                if (withinRange(r, g, b, lnr, lng, lnb, range) &&\r\n                    withinRange(r, g, b, rnr, rng, rnb, range) &&\r\n                    withinRange(r, g, b, tnr, tng, tnb, range) &&\r\n                    withinRange(r, g, b, bnr, bng, bnb, range) &&\r\n                    withinRange(r, g, b, trr, trg, trb, range) &&\r\n                    withinRange(r, g, b, tlr, tlg, tlb, range) &&\r\n                    withinRange(r, g, b, blr, blg, blb, range) &&\r\n                    withinRange(r, g, b, brr, brg, brb, range)) {\r\n                    //make all the neighbors the same color\r\n                    //right\r\n                    d[i + 4] = r;\r\n                    d[i + 5] = g;\r\n                    d[i + 6] = b;\r\n                    //left\r\n                    d[i - 4] = r;\r\n                    d[i - 3] = g;\r\n                    d[i - 2] = b;\r\n                    //above\r\n                    d[i - (maximum)] = r;\r\n                    d[i - (maximum - 1)] = g;\r\n                    d[i - (maximum - 2)] = b;\r\n                    //below\r\n                    d[i + (maximum)] = r;\r\n                    d[i + (maximum + 1)] = g;\r\n                    d[i + (maximum + 2)] = b;\r\n                    //above left\r\n                    d[i - (maximum - 4)] = r;\r\n                    d[i - (maximum - 5)] = g;\r\n                    d[i - (maximum - 6)] = b;\r\n                    //above right\r\n                    d[i - (maximum + 4)] = r;\r\n                    d[i - (maximum + 3)] = g;\r\n                    d[i - (maximum + 2)] = b;\r\n                    //below right\r\n                    d[i + (maximum + 4)] = r;\r\n                    d[i + (maximum + 5)] = g;\r\n                    d[i + (maximum + 6)] = b;\r\n                    //below left\r\n                    d[i + (maximum - 4)] = r;\r\n                    d[i + (maximum - 3)] = g;\r\n                    d[i + (maximum - 2)] = b;\r\n                }\r\n            }\r\n        }\r\n        return pixels;\r\n    };\r\n    /***\r\n    \r\n        mosaic filter\r\n        breaks image into chunks, takes a pixel from each chunk, set all pixels for that chunk\r\n        to that pixel's color\r\n    \r\n    ***/\r\n    this.mosaic = function (pixels) {\r\n        var d = pixels.data;\r\n        var copy = new Uint8ClampedArray(d);\r\n        // get dimensions \r\n        var width = canvas.currentCanvas.getAttribute('width');\r\n        var height = canvas.currentCanvas.getAttribute('height');\r\n        // change sampling size here. lower for higher detail preservation, higher for less detail (because larger chunks)\r\n        var chunkWidth = 40;\r\n        var chunkHeight = 40;\r\n        // make sure chunkWidth can completely divide the image width * 4 \r\n        while (width % chunkWidth != 0) {\r\n            chunkWidth--;\r\n            chunkHeight--;\r\n        }\r\n        // when looking at each chunk of the image, for these 2 outer for loops, \r\n        // focus on looking at each chunk as if looking at a single pixel first (think bigger picture; abstraction!) \r\n        // don't think about selecting single channels yet \r\n        for (var i = 0; i < width; i += chunkWidth) {\r\n            for (var j = 0; j < height; j += chunkHeight) {\r\n                // 4*i + 4*j*width = index of first pixel in chunk \r\n                // get the color of the first pixel in this chunk\r\n                // multiply by 4 because 4 channels per pixel\r\n                // multiply by width because all the image data is in a single array and a row is dependent on width\r\n                var r = copy[4 * i + 4 * j * width];\r\n                var g = copy[4 * i + 4 * j * width + 1];\r\n                var b = copy[4 * i + 4 * j * width + 2];\r\n                // now for all the other pixels in this chunk, set them to this color \r\n                for (var k = i; k < i + chunkWidth; k++) {\r\n                    for (var l = j; l < j + chunkHeight; l++) {\r\n                        d[4 * k + 4 * l * width] = r;\r\n                        d[4 * k + 4 * l * width + 1] = g;\r\n                        d[4 * k + 4 * l * width + 2] = b;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return pixels;\r\n    };\r\n    /***\r\n        this function seems to pixelate an image\r\n        it was my first attempt at the mosaic filter\r\n        and I was getting confused how to traverse chunks of an array\r\n        and ended up with this. the time complexity is very bad\r\n        because my traversal of the chunks in the array is completely wrong\r\n        but sometimes this filter yields interesting results\r\n    ***/\r\n    this.pixelate = function (pixels) {\r\n        var d = pixels.data;\r\n        var copy = new Uint8ClampedArray(d);\r\n        // get dimensions \r\n        var width = canvas.currentCanvas.getAttribute('width');\r\n        var height = canvas.currentCanvas.getAttribute('height');\r\n        var chunkWidth = 100;\r\n        var chunkHeight = 100;\r\n        // make sure chunkWidth can completely divide the image width * 4 \r\n        while (width % chunkWidth != 0) {\r\n            chunkWidth--;\r\n            chunkHeight--;\r\n        }\r\n        for (var i = 0; i < d.length; i += chunkWidth * 2) {\r\n            for (var j = 0; j < height; j += chunkHeight) {\r\n                // 4i + j = index of first pixel in chunk \r\n                var r = copy[4 * i + j];\r\n                var g = copy[4 * i + j + 1];\r\n                var b = copy[4 * i + j + 2];\r\n                for (var k = 4 * i; k < (4 * i) + (4 * chunkWidth); k += 4) {\r\n                    for (var l = j; l < j + chunkHeight; l++) {\r\n                        d[k + l] = r;\r\n                        d[k + l + 1] = g;\r\n                        d[k + l + 2] = b;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return pixels;\r\n    };\r\n    /***\r\n        control brightness - increase\r\n    ***/\r\n    function incBright(pixels) {\r\n        var d = pixels.data;\r\n        for (var i = 0; i < d.length; i += 4) {\r\n            d[i] += 5;\r\n            d[i + 1] += 5;\r\n            d[i + 2] += 5;\r\n            //d[i+3] += 5;\r\n        }\r\n        return pixels;\r\n    }\r\n    //control brightness - decrease\r\n    function decBright(pixels) {\r\n        var d = pixels.data;\r\n        for (var i = 0; i < d.length; i += 4) {\r\n            d[i] -= 5;\r\n            d[i + 1] -= 5;\r\n            d[i + 2] -= 5;\r\n            //d[i+3] -= 5;\r\n        }\r\n        return pixels;\r\n    }\r\n    /***\r\n        change contrast\r\n        set range -128 to 128 for now\r\n        I don't think it's working quite right...\r\n        basically, all dark colors should get darker, and light colors should get lighter right?\r\n    ***/\r\n    //this var is reset when importing a new picture\r\n    var contrastVal = 0;\r\n    function inContrast(pixels) {\r\n        var d = pixels.data;\r\n        if (contrastVal < 128) {\r\n            contrastVal++;\r\n        }\r\n        var contrastFactor = Math.max(((128 + contrastVal) / 128), 0);\r\n        for (var i = 0; i < d.length; i += 4) {\r\n            d[i] = d[i] * contrastFactor;\r\n            d[i + 1] = d[i + 1] * contrastFactor;\r\n            d[i + 2] = d[i + 2] * contrastFactor;\r\n            d[i + 3] = d[i + 3] * contrastFactor;\r\n        }\r\n        return pixels;\r\n    }\r\n    function deContrast(pixels) {\r\n        var d = pixels.data;\r\n        if (contrastVal > -128) {\r\n            contrastVal--;\r\n        }\r\n        var contrastFactor = Math.max(((128 + contrastVal) / 128), 0);\r\n        for (var i = 0; i < d.length; i += 4) {\r\n            d[i] = d[i] * contrastFactor;\r\n            d[i + 1] = d[i + 1] * contrastFactor;\r\n            d[i + 2] = d[i + 2] * contrastFactor;\r\n            d[i + 3] = d[i + 3] * contrastFactor;\r\n        }\r\n        return pixels;\r\n    }\r\n    /***\r\n\r\n        voronoi filter\r\n        https://softwarebydefault.com/tag/voronoi-diagrams/\r\n        https://www.codeproject.com/Articles/882739/Simple-approach-to-Voronoi-diagrams\r\n        \r\n        - nearest neighbor automatically creates 'boundaries'.\r\n        - for each pixel, find the nearest neighbor (a collection of pre-selected pixels)\r\n        - color that pixel whatever the nearest neighbor's color is\r\n        - evenly spaced neighbors will yield a mosaic! awesome!\r\n        \r\n    ***/\r\n    // kd tree to be used in Voronoi function \r\n    // https://blog.krum.io/k-d-trees/\r\n    // https://github.com/z2oh/chromatic_confinement/blob/master/src/main.rs\r\n    // https://stackoverflow.com/questions/1627305/nearest-neighbor-k-d-tree-wikipedia-proof/37107030#37107030\r\n    // each node takes Point info (x, y, rgb) and a dimension\r\n    function Point(x, y, r, g, b) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n    }\r\n    function Node(point, dim) {\r\n        this.data = [point.x, point.y];\r\n        this.point = point;\r\n        this.dim = dim;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n    function getPixelCoords(index, width, height) {\r\n        // assuming index represents the r channel of a pixel \r\n        // index therefore represents the index of a pixel, since the pixel data \r\n        // is laid out like r,g,b,a,r,g,b,a,... in the image data \r\n        // so to figure out the x and y coords, take the index and divide by 4,\r\n        // which gives us the pixel's number. then we need to know its position \r\n        // on the canvas.\r\n        if ((width * 4) * height < index) {\r\n            // if index is out of bounds \r\n            return {};\r\n        }\r\n        var pixelNum = Math.floor(index / 4);\r\n        var yCoord = Math.floor(pixelNum / width); // find what row this pixel belongs in\r\n        var xCoord = pixelNum - (yCoord * width); // find the difference between the pixel number of the pixel at the start of the row and this pixel \r\n        return { 'x': xCoord, 'y': yCoord };\r\n    }\r\n    function getDist(x1, x2, y1, y2) {\r\n        // removing Math.sqrt from the equation seemed to be the fix in producing \r\n        // the correct output (with sqrt it looks like you get the wrong neighbor choices for some points going along a diagonal in the image)\r\n        // not sure why? however, with Math.sqrt it's considerably faster...\r\n        return Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);\r\n    }\r\n    // in this use case our dimensions will be x and y (since each pixel has an x,y coordinate)\r\n    // so only 2 dimensions \r\n    function build2dTree(pointsList, currDim) {\r\n        var maxDim = 2;\r\n        // sort the current list in ascending order depending on the current dimension\r\n        var dim = currDim === 0 ? 'x' : 'y';\r\n        pointsList.sort(function (a, b) {\r\n            if (a[dim] < b[dim]) {\r\n                return -1;\r\n            }\r\n            else if (a[dim] > b[dim]) {\r\n                return 1;\r\n            }\r\n            else {\r\n                return 0;\r\n            }\r\n        });\r\n        // base case: if pointsList is size 0, return null. otherwise if size 1, place the point and return \r\n        if (pointsList.length === 0) {\r\n            return null;\r\n        }\r\n        if (pointsList.length === 1) {\r\n            return new Node(pointsList[0], currDim);\r\n        }\r\n        if (pointsList.length === 2) {\r\n            // since it's a BST, the 2nd element (at index 1) will be larger and thus the parent of \r\n            // the 1st element, which will go to the left of the parent\r\n            var newParent = new Node(pointsList[1], currDim);\r\n            var newChild = new Node(pointsList[0], (currDim + 1) % maxDim);\r\n            newParent.left = newChild;\r\n            return newParent;\r\n        }\r\n        // take the median point, place it, and recurse on left and right \r\n        var midIndex = Math.floor((pointsList.length - 1) / 2);\r\n        var newNode = new Node(pointsList[midIndex], currDim);\r\n        newNode.left = build2dTree(pointsList.slice(0, midIndex), (currDim + 1) % maxDim);\r\n        newNode.right = build2dTree(pointsList.slice(midIndex + 1, pointsList.length), (currDim + 1) % maxDim);\r\n        return newNode;\r\n    }\r\n    function getTreeSize(tree) {\r\n        if (tree === null) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return 1 + getTreeSize(tree.left) + getTreeSize(tree.right);\r\n        }\r\n    }\r\n    function isLeaf(node) {\r\n        return node.left === null && node.right === null;\r\n    }\r\n    /* find nearest neighbor in 2d tree given a point's x and y coords and the tree's root\r\n    // incorrect version... doesn't find the most nearest neighbor (but does the job almost correctly)\r\n    function findNearestNeighbor(root, x, y){\r\n        if(root === null){\r\n            return null;\r\n        }\r\n        \r\n        var minDist = getDist(root.data[0], x, root.data[1], y);\r\n        var nearestNeighbor = root;\r\n        var curr = root;\r\n        \r\n        while(!isLeaf(curr)){\r\n            \r\n            // if a node has one child, it will always be the left child\r\n            if(curr.left && !curr.right){\r\n                curr = curr.left;\r\n                continue;\r\n            }\r\n            \r\n            // compare current dist with min dist\r\n            currDist = getDist(curr.data[0], x, curr.data[1], y);\r\n            if(currDist < minDist){\r\n                minDist = currDist;\r\n                nearestNeighbor = curr;\r\n            }\r\n            \r\n            // find the right direction to go in the tree based on dimension //distance\r\n            var currDimToCompare = (curr.dim === 0) ? x : y;\r\n            \r\n            if(currDimToCompare === x){\r\n                // is x greater than the current node's x? if so, we want to go right. else left.\r\n                if(x > curr.data[0]){\r\n                    curr = curr.right;\r\n                }else{\r\n                    curr = curr.left;\r\n                }\r\n            }else{\r\n                if(y > curr.data[1]){\r\n                    curr = curr.right;\r\n                }else{\r\n                    curr = curr.left;\r\n                }\r\n            }\r\n            \r\n        }\r\n        \r\n        return nearestNeighbor.point;\r\n\r\n    }*/\r\n    // find nearest neighbor in 2d tree given a point's x and y coords and the tree's root \r\n    function findNearestNeighbor(root, x, y) {\r\n        var record = {};\r\n        // set default values \r\n        record.nearestNeighbor = root.point;\r\n        record.minDist = getDist(root.data[0], x, root.data[1], y);\r\n        // pass record to the recursive nearest-neighbor helper function so that it gets updated\r\n        findNearestNeighborHelper(root, record, x, y);\r\n        return record.nearestNeighbor;\r\n    }\r\n    function findNearestNeighborHelper(root, record, x, y) {\r\n        if (isLeaf(root)) {\r\n            var dist = getDist(root.data[0], x, root.data[1], y);\r\n            if (dist < record.minDist) {\r\n                record.nearestNeighbor = root.point;\r\n                record.minDist = dist;\r\n            }\r\n        }\r\n        else {\r\n            // compare current dist with min dist \r\n            currDist = getDist(root.data[0], x, root.data[1], y);\r\n            if (currDist < record.minDist) {\r\n                record.nearestNeighbor = root.point;\r\n                record.minDist = currDist;\r\n            }\r\n            if (root.left && !root.right) {\r\n                // if a node has one child, it will always be the left child \r\n                findNearestNeighborHelper(root.left, record, x, y);\r\n            }\r\n            else {\r\n                // find the right direction to go in the tree based on dimension //distance\r\n                var currDimToCompare = (root.dim === 0) ? x : y;\r\n                if (currDimToCompare === x) {\r\n                    // is x greater than the current node's x? if so, we want to go right. else left.\r\n                    if (x > root.data[0]) {\r\n                        findNearestNeighborHelper(root.right, record, x, y);\r\n                        // then, we check if the other subtree might actually have an even closer neighbor!\r\n                        if (x - record.minDist < root.data[0]) {\r\n                            findNearestNeighborHelper(root.left, record, x, y);\r\n                        }\r\n                    }\r\n                    else {\r\n                        findNearestNeighborHelper(root.left, record, x, y);\r\n                        if (x + record.minDist > root.data[0]) {\r\n                            // x + record.minDist forms a circle. the circle in this case\r\n                            // encompasses this current node's coordinates, so we can get closer to the query node \r\n                            // by checking the right subtree \r\n                            findNearestNeighborHelper(root.right, record, x, y);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (y > root.data[1]) {\r\n                        findNearestNeighborHelper(root.right, record, x, y);\r\n                        if (y - record.minDist < root.data[1]) {\r\n                            findNearestNeighborHelper(root.left, record, x, y);\r\n                        }\r\n                    }\r\n                    else {\r\n                        findNearestNeighborHelper(root.left, record, x, y);\r\n                        if (y + record.minDist > root.data[1]) {\r\n                            findNearestNeighborHelper(root.right, record, x, y);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    this.voronoi = function (pixels) {\r\n        var context = canvas.currentCanvas.getContext(\"2d\");\r\n        var width = canvas.currentCanvas.getAttribute('width');\r\n        var height = canvas.currentCanvas.getAttribute('height');\r\n        var imgData = context.getImageData(0, 0, width, height);\r\n        var data = pixels.data; //imgData.data;\r\n        var neighborList = []; // array of Points \r\n        for (var i = 0; i < data.length; i += 4) {\r\n            // get neighbors.\r\n            // add some offset to each neighbor for randomness (we don't really want evenly spaced neighbors)\r\n            var offset = Math.floor(Math.random() * 10); // to be applied in x or y direction\r\n            var sign = Math.random() > .5 ? 1 : -1;\r\n            var c1 = getPixelCoords(i, width, height);\r\n            if (c1.x % Math.floor(width / 30) === 0 && c1.y % Math.floor(height / 30) === 0 && c1.x !== 0) {\r\n                var x = (sign * offset) + c1.x;\r\n                var y = (sign * offset) + c1.y;\r\n                var p1 = new Point(x, y, data[i], data[i + 1], data[i + 2]);\r\n                neighborList.push(p1);\r\n            }\r\n        }\r\n        var kdtree = build2dTree(neighborList, 0);\r\n        console.log(kdtree);\r\n        for (var i = 0; i < data.length; i += 4) {\r\n            var currCoords = getPixelCoords(i, width, height);\r\n            var nearestNeighbor = findNearestNeighbor(kdtree, currCoords.x, currCoords.y);\r\n            /* naive way of finding nearest neighbor...\r\n            var nearestNeighbor = neighborList[0];\r\n            var minDist = getDist(nearestNeighbor.x, currCoords.x, nearestNeighbor.y, currCoords.y);\r\n            \r\n            // find the nearest neighbor for this pixel\r\n            for(let j = 0; j < neighborList.length; j++){\r\n                var neighbor = neighborList[j];\r\n                var dist = getDist(neighbor.x, currCoords.x, neighbor.y, currCoords.y);\r\n                if(dist < minDist){\r\n                    minDist = dist;\r\n                    nearestNeighbor = neighborList[j];\r\n                }\r\n            }*/\r\n            // found nearest neighbor. color the current pixel the color of the nearest neighbor. \r\n            data[i] = nearestNeighbor.r;\r\n            data[i + 1] = nearestNeighbor.g;\r\n            data[i + 2] = nearestNeighbor.b;\r\n        }\r\n        return pixels;\r\n    };\r\n    // edge detection\r\n    this.edgeDetect = function (pixels) {\r\n        var context = canvas.currentCanvas.getContext(\"2d\");\r\n        var width = canvas.currentCanvas.getAttribute('width');\r\n        var height = canvas.currentCanvas.getAttribute('height');\r\n        var imgData = context.getImageData(0, 0, width, height);\r\n        var data = pixels.data;\r\n        var sourceImageCopy = new Uint8ClampedArray(data);\r\n        pixels = self.grayscale(pixels);\r\n        var xKernel = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];\r\n        var yKernel = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];\r\n        for (var i = 1; i < height - 1; i++) {\r\n            for (var j = 4; j < 4 * width - 4; j += 4) {\r\n                var left = (4 * i * width) + (j - 4);\r\n                var right = (4 * i * width) + (j + 4);\r\n                var top = (4 * (i - 1) * width) + j;\r\n                var bottom = (4 * (i + 1) * width) + j;\r\n                var topLeft = (4 * (i - 1) * width) + (j - 4);\r\n                var topRight = (4 * (i - 1) * width) + (j + 4);\r\n                var bottomLeft = (4 * (i + 1) * width) + (j - 4);\r\n                var bottomRight = (4 * (i + 1) * width) + (j + 4);\r\n                var center = (4 * width * i) + j;\r\n                // use the xKernel to detect edges horizontally \r\n                var pX = (xKernel[0][0] * sourceImageCopy[topLeft]) + (xKernel[0][1] * sourceImageCopy[top]) + (xKernel[0][2] * sourceImageCopy[topRight]) +\r\n                    (xKernel[1][0] * sourceImageCopy[left]) + (xKernel[1][1] * sourceImageCopy[center]) + (xKernel[1][2] * sourceImageCopy[right]) +\r\n                    (xKernel[2][0] * sourceImageCopy[bottomLeft]) + (xKernel[2][1] * sourceImageCopy[bottom]) + (xKernel[2][2] * sourceImageCopy[bottomRight]);\r\n                // use the yKernel to detect edges vertically \r\n                var pY = (yKernel[0][0] * sourceImageCopy[topLeft]) + (yKernel[0][1] * sourceImageCopy[top]) + (yKernel[0][2] * sourceImageCopy[topRight]) +\r\n                    (yKernel[1][0] * sourceImageCopy[left]) + (yKernel[1][1] * sourceImageCopy[center]) + (yKernel[1][2] * sourceImageCopy[right]) +\r\n                    (yKernel[2][0] * sourceImageCopy[bottomLeft]) + (yKernel[2][1] * sourceImageCopy[bottom]) + (yKernel[2][2] * sourceImageCopy[bottomRight]);\r\n                // finally set the current pixel to the new value based on the formula \r\n                var newVal = (Math.ceil(Math.sqrt((pX * pX) + (pY * pY))));\r\n                data[center] = newVal;\r\n                data[center + 1] = newVal;\r\n                data[center + 2] = newVal;\r\n                data[center + 3] = 255;\r\n            }\r\n        }\r\n        return pixels;\r\n    };\r\n} // end filter object\r\n\r\nexport {\r\n\tFilters\r\n};"],"sourceRoot":""}