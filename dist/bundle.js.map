{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./built/SuperCanvas.js","webpack:///./index.js","webpack:///./built/Brush.js","webpack:///./built/Toolbar.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Frame","container","number","this","width","height","currentIndex","canvasList","currentCanvas","tainted","count","getMetadata","getCurrCanvas","setupNewLayer","newCanvas","document","createElement","id","setCanvas","style","opacity","zIndex","getElementById","appendChild","canvas","top","offsetTop","left","offsetLeft","push","hide","forEach","visibility","show","copyCanvas","getContext","drawImage","clearCurrentLayer","currLayer","context","clearRect","getAttribute","fillStyle","fillRect","resetFrame","canvasElement","position","border","setAttribute","addEventListener","$","css","project","currentFrame","speed","frameList","onionSkinFrame","createOnionSkinFrame","display","resetProject","frame","frameIndex","parent","layer","layerIndex","removeChild","addNewFrame","showFlag","newFrame","length","nextFrame","prevFrame","getCurrFrame","updateOnionSkin","onionSkinCtx","onionSkinImageData","getImageData","imageData","data","putImageData","newBrush","animationProject","previousCanvas","undefined","currentCanvasSnapshots","selectedBrush","currColor","currColorArray","Uint8Array","from","currSize","tempSnapshot","clickX","clickY","clickDrag","clickColor","clickSize","thisBrushInstance","radialGrad","x","y","radGrad","createRadialGradient","colorPicked","addColorStop","resetBrush","curCanvas","off","addClick","dragging","redraw","lineJoin","beginPath","moveTo","lineTo","closePath","strokeStyle","lineWidth","stroke","changeBrushSize","size","defaultBrush","paint","on","e","which","type","rect","target","getBoundingClientRect","offsetX","originalEvent","touches","pageX","offsetY","pageY","preventDefault","w","h","mouseleave","radialGradBrush","lineCap","mousedown","mousemove","mouseup","newToolbar","brush","animationProj","recentImage","play","timePerFrame","layerMode","htmlCounter","setCounter","elementId","up","down","curr","next","prev","addPage","setKeyDown","doc","toolbar","counterText","keydown","counterUpdateString","textContent","insertLayer","click","newestCanvas","pop","splice","deleteLayer","toolbarReference","oldCanvasIndex","oldCanvasId","parentNode","addNewFrameButton","createColorWheel","location","colorWheel","colorWheelContext","angle","startAngle","Math","PI","endAngle","arc","gradient","fill","showColor","textAlign","colorPickedText","floodFill","doFloodFill","substring","indexOf","split","map","a","parseInt","offset","colorData","color","console","log","pixel","floor","newColor","pixelSelected","stack","visited","targetColor","ctx","currPixel","g","b","leftNeighborX","rightNeighborX","topNeighborY","bottomNeighborY","floodfill","removeEventListener","rotateImage","Promise","all","createImageBitmap","then","bitmap","translate","rotate","setClearCanvas","undo","unshift","mostRecentImage","importImage","input","getFile","img","Image","reader","FileReader","file","files","match","onload","onloadend","src","result","readAsDataURL","resetImage","download","toBlob","blob","url","URL","createObjectURL","link","href","prompt","playFor","playBack","playForward","clearInterval","setInterval","playBackward","stop","getGif","gif","GIF","workers","quality","tempCanvas","tempCtx","tempImageData","currFrame","j","k","addFrame","delay","newGif","window","open","render","save","savedData","newLayer","toDataURL","layers","JSON","stringify","json","join","Blob","importProject","counterId","self","parse","index","currFrameLayersFromImport","currFrameLayersFromCurrPrj","image","newCtx","readAsText","element","Filters","showOptions","category","el","child","children","marginBottom"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","// TODO: have an animation mode and a paint mode? in paint mode, you can do all the layering per frame and stuff.\r\n// in animation mode, we process all the frames and for each one condense all their layers into a single frame.\r\n// then we can use those frames in an animation.\r\n// to optimize performance when going into animation mode, maybe cache which frames are 'tainted' from the last time \r\n// animation mode was switched to.\r\n/***\r\n    super canvas class\r\n    the instance variables hold the default attributes for any canvas.\r\n    it also holds important information like a list of all the canvas instances.\r\n    setupNewCanvas should be used to create a new canvas instance\r\n    @param container = the parent element ID (i.e. of a div) to append the canvas elements to\r\n    \r\n    a supercanvas is really a frame, containing a list of canvas elements which represent layers of the frame\r\n***/\r\n\r\nfunction Frame(container, number) {\r\n    this.width = 800; // default value\r\n    this.height = 800;\r\n    this.currentIndex = 0;\r\n    this.canvasList = []; // keep a list of all canvas instances\r\n    this.currentCanvas; // the current, active canvas being looked at (reference to html element)\r\n    this.container = container; // this is the html container id to hold all the layers of this frame\r\n    this.tainted = false; // set to true if any layers are edited\r\n    this.number = number; // frame number\r\n    this.count = 0; // current number of layers\r\n    this.getMetadata = function () {\r\n        return {\r\n            'width': this.width,\r\n            'height': this.height,\r\n            'currentIndex': this.currentIndex,\r\n            'number': this.number\r\n        };\r\n    };\r\n    this.getCurrCanvas = function () {\r\n        return this.canvasList[this.currentIndex];\r\n    };\r\n    /***\r\n        set up a new canvas element\r\n        makes the new canvas the current canvas\r\n    ***/\r\n    this.setupNewLayer = function () {\r\n        // create the new canvas element \r\n        var newCanvas = document.createElement('canvas');\r\n        newCanvas.id = \"frame\" + this.number + \"canvas\" + this.count;\r\n        setCanvas(newCanvas, this.width, this.height);\r\n        if (this.count === 0) {\r\n            newCanvas.style.opacity = .97;\r\n            newCanvas.style.zIndex = 1;\r\n        }\r\n        // add it to the container passed in as the argument\r\n        document.getElementById(this.container).appendChild(newCanvas);\r\n        // set new canvas to be the current canvas only initially!\r\n        if (this.count === 0) {\r\n            this.currentCanvas = newCanvas;\r\n        }\r\n        // if at least 1 canvas already present, make the previous canvas be slightly opaque for onion-skin effect\r\n        if (this.count >= 1) {\r\n            // position the new canvas directly on top of the previous one \r\n            var canvas = document.getElementById(this.canvasList[0].id);\r\n            var top = canvas.offsetTop;\r\n            var left = canvas.offsetLeft;\r\n            newCanvas.style.top = top;\r\n            newCanvas.style.left = left;\r\n        }\r\n        this.canvasList.push(newCanvas);\r\n        this.count++;\r\n    };\r\n    this.hide = function () {\r\n        // puts all layers at zIndex -1 so they're not visible\r\n        this.canvasList.forEach(function (canvas) {\r\n            canvas.style.zIndex = -1;\r\n            canvas.style.visibility = 'hidden';\r\n        });\r\n    };\r\n    this.show = function () {\r\n        // makes all layers visible\r\n        this.canvasList.forEach(function (canvas) {\r\n            canvas.style.zIndex = 1;\r\n            canvas.style.visibility = '';\r\n        });\r\n    };\r\n    /***\r\n        clone the current canvas\r\n    ***/\r\n    this.copyCanvas = function () {\r\n        var newCanvas = document.createElement('canvas');\r\n        newCanvas.id = 'frame' + this.number + 'canvas' + this.count;\r\n        setCanvas(newCanvas, this.width, this.height);\r\n        this.canvasList[this.count - 1].style.opacity = .92;\r\n        // place the canvas in the container \r\n        document.getElementById(container).appendChild(newCanvas);\r\n        // position the new canvas directly on top of the previous one \r\n        var canvas = document.getElementById(this.canvasList[0].id);\r\n        var top = canvas.offsetTop;\r\n        var left = canvas.offsetLeft;\r\n        newCanvas.style.top = top;\r\n        newCanvas.style.left = left;\r\n        newCanvas.getContext(\"2d\").drawImage(this.currentCanvas, 0, 0);\r\n        this.canvasList.push(newCanvas);\r\n        this.count++;\r\n    };\r\n    this.clearCurrentLayer = function () {\r\n        var currLayer = this.getCurrCanvas();\r\n        var context = currLayer.getContext(\"2d\");\r\n        context.clearRect(0, 0, currLayer.getAttribute('width'), currLayer.getAttribute('height'));\r\n        context.fillStyle = \"#FFFFFF\";\r\n        context.fillRect(0, 0, currLayer.getAttribute('width'), currLayer.getAttribute('height'));\r\n    };\r\n    this.resetFrame = function () {\r\n    };\r\n}\r\n/***\r\n    an animation is a single project containing one or more supercanvases (or frames).\r\n    it also instantiates an onion skin frame.\r\n***/\r\nfunction AnimationProject(container) {\r\n    this.name = \"\";\r\n    this.currentFrame = 0; // should this be a ref to the current frame!?\r\n    this.speed = 100; // 100 ms per frame \r\n    this.frameList = [];\r\n    this.mode = 0; // 0 == drawing mode. 1 == animation mode.\r\n    this.onionSkinFrame = createOnionSkinFrame(container);\r\n    this.onionSkinFrame.style.display = 'none'; // hide it initially\r\n    this.container = container; // id of the html element the frames are displayed in\r\n    this.resetProject = function () {\r\n        this.frameList.forEach(function (frame, frameIndex) {\r\n            // remove each layer from the DOM \r\n            var parent = document.getElementById(frame['container']);\r\n            // just keep the first layer\r\n            frame.canvasList.forEach(function (layer, layerIndex) {\r\n                if (layerIndex > 0) {\r\n                    parent.removeChild(layer);\r\n                }\r\n            });\r\n            frame.canvasList = [frame.canvasList[0]];\r\n            if (frameIndex === 0) {\r\n                frame.currentIndex = 0;\r\n                frame.currentCanvas = frame.canvasList[0];\r\n            }\r\n        });\r\n        this.frameList = [this.frameList[0]]; // just keep the first frame.\r\n        // clear the first layer of the first frame!\r\n        this.frameList[0].clearCurrentLayer();\r\n        this.currentFrame = 0;\r\n        this.mode = 0;\r\n        this.speed = 100;\r\n    };\r\n    this.addNewFrame = function (showFlag) {\r\n        var newFrame = new Frame(this.container, this.frameList.length);\r\n        newFrame.setupNewLayer();\r\n        this.frameList.push(newFrame);\r\n        if (!showFlag) {\r\n            newFrame.hide();\r\n        }\r\n    };\r\n    this.nextFrame = function () {\r\n        if (this.frameList.length === this.currentFrame + 1) {\r\n            return null; // no more frames to see\r\n        }\r\n        this.currentFrame += 1;\r\n        return this.frameList[this.currentFrame];\r\n    };\r\n    this.prevFrame = function () {\r\n        if (this.currentFrame - 1 < 0) {\r\n            return null; // no more frames to see\r\n        }\r\n        this.currentFrame -= 1;\r\n        return this.frameList[this.currentFrame];\r\n    };\r\n    this.getCurrFrame = function () {\r\n        return this.frameList[this.currentFrame];\r\n    };\r\n    this.updateOnionSkin = function () {\r\n        if (this.currentFrame - 1 < 0) {\r\n            return;\r\n        }\r\n        // https://stackoverflow.com/questions/6787899/combining-two-or-more-canvas-elements-with-some-sort-of-blending\r\n        this.onionSkinFrame.style.display = ''; // show onion skin\r\n        var onionSkinCtx = this.onionSkinFrame.getContext(\"2d\");\r\n        onionSkinCtx.clearRect(0, 0, this.onionSkinFrame.width, this.onionSkinFrame.height);\r\n        // take the previous frame, merge all layers, put into onion skin frame\r\n        // try this? only draw pixels that are non-white?\r\n        var onionSkinImageData = onionSkinCtx.getImageData(0, 0, this.onionSkinFrame.width, this.onionSkinFrame.height);\r\n        // build the merged image from the first to last\r\n        var prevFrame = this.frameList[this.currentFrame - 1];\r\n        prevFrame.canvasList.forEach(function (layer) {\r\n            var imageData = layer.getContext(\"2d\").getImageData(0, 0, layer.width, layer.height).data;\r\n            for (var i = 0; i < imageData.length; i += 4) {\r\n                if (imageData[i] === 255 && imageData[i + 1] === 255 && imageData[i + 2] === 255) {\r\n                    continue;\r\n                }\r\n                else {\r\n                    // what if the canvas we're getting image data from to draw on the onion skin is LARGER than the onion skin canvas.\r\n                    // we might run into index/length issues...\r\n                    onionSkinImageData.data[i] = imageData[i];\r\n                    onionSkinImageData.data[i + 1] = imageData[i + 1];\r\n                    onionSkinImageData.data[i + 2] = imageData[i + 2];\r\n                    onionSkinImageData.data[i + 3] = 255;\r\n                }\r\n            }\r\n            // apply each layer to the onion skin\r\n            onionSkinCtx.putImageData(onionSkinImageData, 0, 0);\r\n        });\r\n        this.onionSkinFrame.style.zIndex = 0;\r\n        this.onionSkinFrame.style.opacity = 0.92;\r\n    };\r\n}\r\n\r\nfunction createOnionSkinFrame(container) {\r\n    var width = 800;\r\n    var height = 800;\r\n    // create the new canvas element \r\n    var newCanvas = document.createElement('canvas');\r\n    newCanvas.id = \"onionSkinCanvas\";\r\n    setCanvas(newCanvas, width, height);\r\n    newCanvas.style.opacity = .97;\r\n    newCanvas.style.zIndex = -1; // come back to this later. make sure it's visible if current frame > 1!\r\n    // add it to the container passed in as the argument\r\n    document.getElementById(container).appendChild(newCanvas);\r\n    return newCanvas;\r\n}\r\n// assigns position, z-index, border, width, height and opacity\r\nfunction setCanvas(canvasElement, width, height) {\r\n    canvasElement.style.position = 'absolute';\r\n    canvasElement.style.border = '1px #000 solid';\r\n    canvasElement.style.zIndex = 0;\r\n    canvasElement.style.opacity = 0;\r\n    canvasElement.setAttribute('width', width);\r\n    canvasElement.setAttribute('height', height);\r\n    canvasElement.getContext(\"2d\").fillStyle = \"rgba(255,255,255,255)\"; //\"#fff\";\r\n    canvasElement.getContext(\"2d\").fillRect(0, 0, width, height);\r\n}\r\n\r\nexport {\r\n\tFrame,\r\n\tAnimationProject,\r\n\tcreateOnionSkinFrame,\r\n\tsetCanvas\r\n};\r\n","import { Frame, AnimationProject } from './built/SuperCanvas.js';\r\nimport { Brush } from './built/Brush.js';\r\nimport { Toolbar } from './built/Toolbar.js';\r\n\r\n// prevent FOUC\r\ndocument.addEventListener(\"DOMContentLoaded\", function(){\r\n\t$('html').css('display', 'block');\r\n});\r\n\r\n// set up project\r\nvar project = new AnimationProject('canvasArea');\r\nproject.addNewFrame(true); // since it's the first frame, show it\r\nvar newCanvas = project.getCurrFrame(); //new SuperCanvas('canvasArea', project.frameList.length);\r\n//newCanvas.setupNewLayer();\r\n//project.add(newCanvas);\r\n\r\n// set up brush\r\nvar newBrush = new Brush(project);\r\nnewBrush.defaultBrush();\r\n\r\n// set up toolbar \r\n// here I'm passing in element Id's that these functions will attach to\r\nvar newToolbar = new Toolbar(newCanvas, newBrush, project);\r\nnewToolbar.setCounter(\"count\");\r\nnewToolbar.setKeyDown(document);\t// enables new canvas add on spacebar, go to next with right arrow, prev with left arrow.\r\nnewToolbar.createColorWheel('colorPicker', 200);\r\nnewToolbar.floodFill('floodfill');\r\nnewToolbar.insertLayer('insertCanvas');\r\nnewToolbar.deleteLayer('deleteCanvas', 'count');\r\nnewToolbar.setClearCanvas('clearCanvas');\r\nnewToolbar.rotateImage('rotateCanvasImage'); \r\nnewToolbar.undo('undo');\r\nnewToolbar.download('download');\r\nnewToolbar.importImage('importImage');\r\nnewToolbar.save('saveWork');\r\nnewToolbar.importProject('importProject', 'count');\r\nnewToolbar.addNewFrameButton('addNewFrame');\r\n\r\n// make the goLeft and goRight arrows clickable FOR LAYERS\r\n// note: this is for clicking the icons with a mouse!\r\n$('#goLeft').click(function(){\r\n\tif(newToolbar.down()){\r\n\t\tvar curr = project.getCurrFrame();\r\n\t\tdocument.getElementById(\"count\").textContent = \"frame: \" + (project.currentFrame+1) + \", layer: \" + (curr.currentIndex + 1);\r\n\t}\r\n});\r\n$('#goRight').click(function(){\r\n\tif(newToolbar.up()){\r\n\t\tvar curr = project.getCurrFrame();\r\n\t\tdocument.getElementById(\"count\").textContent = \"frame: \" + (project.currentFrame+1) + \", layer: \" + (curr.currentIndex + 1);\r\n\t}\r\n});\r\n\r\n// left and right arrows for FRAMES\r\n$('#prevFrame').click(function(){\r\n\tif(newToolbar.prevFrame()){\r\n\t\tvar curr = project.getCurrFrame();\r\n\t\tdocument.getElementById(\"count\").textContent = \"frame: \" + (project.currentFrame+1) + \", layer: \" + (curr.currentIndex + 1);\r\n\t}\r\n});\r\n\r\n$('#nextFrame').click(function(){\r\n\tif(newToolbar.nextFrame()){\r\n\t\tvar curr = project.getCurrFrame();\r\n\t\tdocument.getElementById(\"count\").textContent = \"frame: \" + (project.currentFrame+1) + \", layer: \" + (curr.currentIndex + 1);\r\n\t}\r\n});\r\n\r\n$('#generateGif').click(function(){\r\n\tnewToolbar.getGif(\"loadingScreen\");\r\n});\r\n\r\n$('#toggleLayerOrFrame').click(function(){\r\n\telement = document.getElementById(\"toggleLayerOrFrame\");\r\n\tif(newToolbar.layerMode){\r\n\t\tnewToolbar.layerMode = false;\r\n\t\telement.textContent = \"toggle layer addition on spacebar press\";\r\n\t}else{\r\n\t\tnewToolbar.layerMode = true;\r\n\t\telement.textContent = \"toggle frame addition on spacebar press\";\r\n\t}\r\n});\r\n\r\n// set up filters object\r\nvar newFilters = new Filters(newCanvas, newBrush);\r\n\r\ndocument.getElementById('filterSelect').addEventListener('click', function(){ showOptions('filters') });\r\ndocument.getElementById('brushSelect').addEventListener('click', function(){ showOptions('brushes') });\r\n\r\n// show options when clicking on filters or brushes \r\nfunction showOptions(category){\r\n\tvar el = document.getElementById(category);\r\n\tvar child = el.children[1]; // skip the p element and get the ul element\r\n\tif(child.style.display !== \"block\" ){\r\n\t\tchild.style.display = \"block\";\r\n\t}else{\r\n\t\tchild.style.display = \"none\";\r\n\t\tel.style.marginBottom  = 0;\r\n\t}\r\n}\r\n\r\n// update brush size display\r\nfunction showSize(){\r\n\tdocument.getElementById('brushSizeValue').textContent = document.getElementById('brushSize').value;\r\n}\r\n\r\n// show some samples/demos!!\r\nfunction getDemo(selectedDemo){\r\n\r\n\t// case for the blank option \r\n\tif(selectedDemo.options[selectedDemo.selectedIndex].text === \"\"){\r\n\t\treturn;\r\n\t}\r\n\r\n\t// get the selected demo from the dropbox\r\n\t// selectedDemo is the path to the demo to load \r\n\tvar selectedDemo = \"demos/\" + selectedDemo.options[selectedDemo.selectedIndex].text + \".json\"; \r\n\r\n\tvar httpRequest = new XMLHttpRequest();\r\n\r\n\tif(!httpRequest){\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t// set request type\r\n\thttpRequest.open(\"GET\", selectedDemo);\r\n\t\r\n\t// what to do when data comes back\r\n\thttpRequest.onload = function(){\r\n\t\t\r\n\t\t// parse the JSON using JSON.parse \r\n\t\tvar data = JSON.parse(httpRequest.responseText);\r\n\r\n\t\tif(!data[0] || (!data[0].name && !data[0].height && !data[0].width && !data[0].data)){\r\n\t\t\tconsole.log(\"it appears to not be a valid project! :<\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// clear existing project\r\n\t\tproject.resetProject();\r\n\t\t// update UI \r\n\t\tif(newToolbar.htmlCounter){\r\n\t\t\t// ideally if you use react or some library that can update the view based on the current state,\r\n\t\t\t// you shouldn't need this at all. hint hint.\r\n\t\t\tnewToolbar.htmlCounter.textContent = \"frame: \" + (project.currentFrame+1) + \", layer: \" + (project.frameList[project.currentFrame].currentIndex + 1);\r\n\t\t}\r\n\t\t\r\n\t\t// load saved project\r\n\t\tdata.forEach(function(frame, index){\r\n\t\t\tif(index > 0){\r\n\t\t\t\t// add a new frame\r\n\t\t\t\tproject.addNewFrame();\r\n\t\t\t}\r\n\t\t\t// overwrite existing frame\r\n\t\t\t// TODO: implement an updateFrame method \r\n\t\t\t// animationProj.updateFrame(0, frame); // updateFrame takes an index of the existing frame to overwrite and takes a SuperCanvas object to update with as well\r\n\t\t\tvar currFrame = project.frameList[index];\r\n\t\t\tconsole.log(\"need to add \" + frame.layers.length + \" layers for frame: \" + (index+1));\r\n\t\t\t\r\n\t\t\tvar currFrameLayersFromImport = frame.layers; // looking at data-to-import's curr frame's layers\r\n\t\t\tvar currFrameLayersFromCurrPrj = currFrame.canvasList;\r\n\t\t\tcurrFrameLayersFromImport.forEach(function(layer, layerIndex){\r\n\t\t\t\tif((layerIndex+1) > currFrameLayersFromCurrPrj.length){\r\n\t\t\t\t\t// add new layer to curr project as needed based on import\r\n\t\t\t\t\tconsole.log(\"need to add a new layer for frame: \" + index);\r\n\t\t\t\t\tproject.frameList[index].setupNewLayer();\r\n\t\t\t\t}\r\n\t\t\t\tvar currLayer = project.frameList[index].canvasList[layerIndex];\r\n\t\t\t\t\r\n\t\t\t\t// is this part necessary? maybe, if you want the project to look exactly as when it was saved.\r\n\t\t\t\tcurrLayer.style.opacity = layer.opacity;\r\n\t\t\t\tcurrLayer.style.zIndex = layer.zIndex;  \r\n\t\t\t\tcurrLayer.height = layer.height;\r\n\t\t\t\tcurrLayer.width = layer.width;\r\n\t\t\t\t\r\n\t\t\t\t// add the image data \r\n\t\t\t\tvar newCtx = currLayer.getContext(\"2d\");\r\n\t\t\t\tvar img = new Image();\r\n\t\t\t\t\r\n\t\t\t\t(function(context, image){\r\n\t\t\t\t\timage.onload = function(){\r\n\t\t\t\t\t\t\tcontext.drawImage(image, 0, 0);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\timage.src = layer.imageData;\r\n\t\t\t\t})(newCtx, img);\r\n\t\t\t\t\r\n\t\t\t});\r\n\t\t});\r\n\t\t\t\t\t\t\r\n\t}\r\n\t\r\n\t// send the request \r\n\thttpRequest.send();\r\n}\r\n","/***\r\n    brush class\r\n    pass in an instance of the SuperCanvas class as an argument\r\n    the canvas argument will have a reference to the current canvas so that\r\n    only the current canvas will be a target for the brush\r\n***/\r\nfunction Brush(animationProject) {\r\n    // pass in an animation project, from which you can access the current frame and the current canvas\r\n    this.previousCanvas = undefined;\r\n    this.currentCanvasSnapshots = []; // keep track of what the current canvas looks like after each mouseup\r\n    this.selectedBrush = 'default'; // user-selected brush \r\n    this.currColor = '#000';\r\n    this.currColorArray = Uint8Array.from([0, 0, 0, 0]);\r\n    this.currSize = 2;\r\n    // these variables keep track of the pixels drawn on by the mouse.\r\n    // the redraw function uses this data to connect the dots \r\n    var clickX = [];\r\n    var clickY = [];\r\n    var clickDrag = [];\r\n    var clickColor = [];\r\n    var clickSize = [];\r\n    // hold the current image after mouseup. \r\n    // only put it in the currentCanvasSnapshots after user starts drawing again, creating a new snapshot\r\n    var tempSnapshot;\r\n    // pass in an instance of the SuperCanvas class as an argument\r\n    // the canvas argument will have a reference to the current canvas so that\r\n    // only the current canvas will be a target for the brush\r\n    // note that a new variable, \"thisBrushInstance\", is assigned this (I want the brush object instance). \r\n    // that is because when you go inside another function (i.e. mousedown), \r\n    // using \"this\" doesn't refer to the object you're in, but that other function itself. \r\n    var thisBrushInstance = this;\r\n    this.changeBrushSize = function (size) {\r\n        this.currSize = size;\r\n    };\r\n    this.defaultBrush = function () {\r\n        // reset mouse action functions first \r\n        resetBrush();\r\n        var canvas = animationProject.getCurrFrame();\r\n        var paint;\r\n        $('#' + canvas.currentCanvas.id).on('mousedown touchstart', function (e) {\r\n            if ((e.which === 1 && e.type === 'mousedown') || e.type === 'touchstart') { //when left click only\r\n                // update previousCanvas\r\n                if (thisBrushInstance.previousCanvas !== canvas.currentCanvas) {\r\n                    thisBrushInstance.previousCanvas = canvas.currentCanvas;\r\n                    // reset the snapshots array\r\n                    thisBrushInstance.currentCanvasSnapshots = [];\r\n                }\r\n                if (tempSnapshot) {\r\n                    thisBrushInstance.currentCanvasSnapshots.push(tempSnapshot);\r\n                }\r\n                paint = true;\r\n                // offset will be different with mobile\r\n                // use e.originalEvent because using jQuery\r\n                // https://stackoverflow.com/questions/17130940/retrieve-the-same-offsetx-on-touch-like-mouse-event\r\n                // https://stackoverflow.com/questions/11287877/how-can-i-get-e-offsetx-on-mobile-ipad\r\n                // using rect seems to work pretty well\r\n                if (e.type === 'touchstart') {\r\n                    var rect = e.target.getBoundingClientRect();\r\n                    e.offsetX = e.originalEvent.touches[0].pageX - rect.left;\r\n                    e.offsetY = e.originalEvent.touches[0].pageY - rect.top;\r\n                }\r\n                addClick(e.offsetX, e.offsetY, true);\r\n                redraw(canvas);\r\n            }\r\n        });\r\n        //draw the lines as mouse moves\r\n        $('#' + canvas.currentCanvas.id).on('mousemove touchmove', function (e) {\r\n            if (paint) {\r\n                if (e.type === 'touchmove') {\r\n                    var rect = e.target.getBoundingClientRect();\r\n                    e.offsetX = e.originalEvent.touches[0].pageX - rect.left;\r\n                    e.offsetY = e.originalEvent.touches[0].pageY - rect.top;\r\n                    // prevent page scrolling when drawing \r\n                    e.preventDefault();\r\n                }\r\n                addClick(e.offsetX, e.offsetY, true);\r\n                redraw(canvas);\r\n            }\r\n        });\r\n        //stop drawing\r\n        $('#' + canvas.currentCanvas.id).on('mouseup touchend', function (e) {\r\n            // see if it's a new canvas or we're still on the same one as before the mousedown\r\n            if (thisBrushInstance.previousCanvas === canvas.currentCanvas) {\r\n                // if it is, then log the current image data. this is important for the undo feature\r\n                var c = canvas.currentCanvas;\r\n                var w = c.width;\r\n                var h = c.height;\r\n                tempSnapshot = canvas.currentCanvas.getContext(\"2d\").getImageData(0, 0, w, h);\r\n            }\r\n            clearClick();\r\n            paint = false;\r\n        });\r\n        //stop drawing when mouse leaves\r\n        $('#' + canvas.currentCanvas.id).mouseleave(function (e) {\r\n            paint = false;\r\n        });\r\n    };\r\n    /***\r\n        radial gradient brush\r\n    ***/\r\n    this.radialGradBrush = function () {\r\n        // reset mouse action functions first \r\n        resetBrush();\r\n        var canvas = animationProject.getCurrFrame();\r\n        var curCanvas = canvas.currentCanvas.id;\r\n        var context = canvas.currentCanvas.getContext(\"2d\");\r\n        var paint;\r\n        context.lineJoin = context.lineCap = 'round';\r\n        $('#' + curCanvas).mousedown(function (e) {\r\n            if (e.which === 1) {\r\n                paint = true;\r\n                radialGrad(e.offsetX, e.offsetY);\r\n            }\r\n        });\r\n        $('#' + curCanvas).mousemove(function (e) {\r\n            if (paint) {\r\n                radialGrad(e.offsetX, e.offsetY);\r\n            }\r\n        });\r\n        $('#' + curCanvas).mouseup(function (e) {\r\n            paint = false;\r\n            if (thisBrushInstance.previousCanvas === canvas.currentCanvas) {\r\n                // if it is, then log the current image data. this is important for the undo feature\r\n                var c = canvas.currentCanvas;\r\n                var w = c.width;\r\n                var h = c.height;\r\n                thisBrushInstance.currentCanvasSnapshots.push(canvas.currentCanvas.getContext(\"2d\").getImageData(0, 0, w, h));\r\n            }\r\n        });\r\n        //stop drawing when mouse leaves\r\n        $('#' + curCanvas).mouseleave(function (e) {\r\n            paint = false;\r\n        });\r\n    };\r\n    function radialGrad(x, y) {\r\n        var canvas = animationProject.getCurrFrame();\r\n        var context = canvas.currentCanvas.getContext(\"2d\");\r\n        var radGrad = context.createRadialGradient(x, y, thisBrushInstance.currSize, x, y, thisBrushInstance.currSize * 1.5);\r\n        var colorPicked = thisBrushInstance.currColorArray;\r\n        radGrad.addColorStop(0, thisBrushInstance.currColor);\r\n        if (colorPicked !== undefined) {\r\n            radGrad.addColorStop(.5, 'rgba(' + colorPicked[0] + ',' + colorPicked[1] + ',' + colorPicked[2] + ',.5)');\r\n            radGrad.addColorStop(1, 'rgba(' + colorPicked[0] + ',' + colorPicked[1] + ',' + colorPicked[2] + ',0)');\r\n        }\r\n        else {\r\n            radGrad.addColorStop(.5, 'rgba(0,0,0,.5)');\r\n            radGrad.addColorStop(1, 'rgba(0,0,0,0)');\r\n        }\r\n        context.fillStyle = radGrad;\r\n        context.fillRect(x - 20, y - 20, 40, 40);\r\n    }\r\n    function resetBrush() {\r\n        var canvas = animationProject.getCurrFrame();\r\n        var curCanvas = canvas.getCurrCanvas().id; //canvas.currentCanvas.id;\r\n        //detach any events from mouse actions (reset the events connected with mouse events)\r\n        $('#' + curCanvas).off(\"mousedown\");\r\n        $('#' + curCanvas).off(\"mouseup\");\r\n        $('#' + curCanvas).off(\"mousemove\");\r\n    }\r\n    //collect info where each pixel is to be drawn on canvas\r\n    function addClick(x, y, dragging) {\r\n        //var brushInstance = \r\n        clickX.push(x);\r\n        clickY.push(y);\r\n        clickDrag.push(dragging);\r\n        clickColor.push(thisBrushInstance.currColor);\r\n        clickSize.push(thisBrushInstance.currSize);\r\n    }\r\n    function redraw(canvas) {\r\n        var canvas = animationProject.getCurrFrame();\r\n        var context = canvas.currentCanvas.getContext(\"2d\");\r\n        context.lineJoin = 'round';\r\n        for (var i = 0; i < clickX.length; i++) {\r\n            context.beginPath();\r\n            //this helps generate a solid line, rather than a line of dots. \r\n            //the subtracting of 1 from i means that the point at i is being connected\r\n            //with the previous point\r\n            if (clickDrag[i] && i) {\r\n                context.moveTo(clickX[i - 1], clickY[i - 1]);\r\n            }\r\n            else {\r\n                //the adding of 1 allows you to make a dot on click\r\n                context.moveTo(clickX[i], clickY[i] + 1);\r\n            }\r\n            context.lineTo(clickX[i], clickY[i]);\r\n            context.closePath();\r\n            context.strokeStyle = clickColor[i];\r\n            context.lineWidth = clickSize[i];\r\n            context.stroke();\r\n        }\r\n    }\r\n    function clearClick() {\r\n        clickX = [];\r\n        clickY = [];\r\n        clickDrag = [];\r\n        clickColor = [];\r\n        clickSize = [];\r\n    }\r\n}\r\n\r\nexport {\r\n\tBrush\r\n};\r\n","// toolbar class\r\n// assemble the common functions for the toolbar\r\n// remove canvas param since you have animationProj\r\nfunction Toolbar(canvas, brush, animationProj) {\r\n    // keep this variable for storing the most recent imported image\r\n    // can be useful for resetting image\r\n    var recentImage;\r\n    // used as a counter for the animation playback features\r\n    var play = null;\r\n    // this will only work for the very first frame!!\r\n    // when each method is called, the current canvas needs to be recalculated\r\n    //var canvas = animationProj.frameList[animationProj.currentFrame];\r\n    // used to hold user-indicated time (ms) per frame for animation playback and gif\r\n    this.timePerFrame = 200; // set to 200 be default\r\n    // should the keyboard keys be affecting the layer or the frame? 2 options only\r\n    // this is useful for the arrow keys and space bar\r\n    this.layerMode = true;\r\n    this.htmlCounter = \"\"; // html element used as a counter specifying the current frame and layer\r\n    this.setCounter = function (elementId) {\r\n        this.htmlCounter = document.getElementById(elementId);\r\n    };\r\n    this.up = function () {\r\n        // this moves the current layer to the next one if exists\r\n        var canvas = animationProj.getCurrFrame();\r\n        if (canvas.currentIndex + 1 < canvas.canvasList.length) {\r\n            // move to next canvas\r\n            canvas.currentCanvas.style.opacity = .92; // apply onion skin to current canvas \r\n            canvas.currentCanvas.style.zIndex = 0;\r\n            // in the special case for when you want to go to the next canvas from the very first one, \r\n            // ignore the step where the opacity and z-index for the previous canvas get reset to 0.\r\n            if (canvas.currentIndex > 0) {\r\n                // reset opacity and z-index for previous canvas (because of onionskin)\r\n                canvas.canvasList[canvas.currentIndex - 1].style.opacity = 0;\r\n                canvas.canvasList[canvas.currentIndex - 1].style.zIndex = 0;\r\n            }\r\n            // show the next canvas \r\n            canvas.canvasList[canvas.currentIndex + 1].style.opacity = .97;\r\n            canvas.canvasList[canvas.currentIndex + 1].style.zIndex = 1;\r\n            canvas.currentCanvas = canvas.canvasList[canvas.currentIndex + 1];\r\n            canvas.currentIndex++;\r\n            // apply brush on new current canvas \r\n            brush.defaultBrush();\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    this.down = function () {\r\n        // this moves the current layer to the previous one if exists\r\n        var canvas = animationProj.getCurrFrame();\r\n        if (canvas.currentIndex - 1 >= 0) {\r\n            // move to previous canvas \r\n            // first make current canvas not visible anymore\r\n            canvas.currentCanvas.style.opacity = 0;\r\n            canvas.currentCanvas.style.zIndex = 0;\r\n            // make previous canvas visible \r\n            canvas.canvasList[canvas.currentIndex - 1].style.opacity = .97;\r\n            canvas.canvasList[canvas.currentIndex - 1].style.zIndex = 1;\r\n            // if there is another canvas before the previous one, apply onion skin\r\n            if (canvas.currentIndex - 2 >= 0) {\r\n                canvas.canvasList[canvas.currentIndex - 2].style.opacity = .92;\r\n            }\r\n            canvas.currentCanvas = canvas.canvasList[canvas.currentIndex - 1];\r\n            canvas.currentIndex--;\r\n            // apply brush\r\n            brush.defaultBrush();\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    this.nextFrame = function () {\r\n        var curr = animationProj.getCurrFrame();\r\n        var next = animationProj.nextFrame();\r\n        if (next !== null) {\r\n            curr.hide();\r\n            next.show();\r\n            animationProj.updateOnionSkin();\r\n            brush.defaultBrush();\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    this.prevFrame = function () {\r\n        var curr = animationProj.getCurrFrame();\r\n        var prev = animationProj.prevFrame();\r\n        if (prev !== null) {\r\n            curr.hide();\r\n            prev.show();\r\n            animationProj.updateOnionSkin();\r\n            brush.defaultBrush();\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    this.addPage = function () {\r\n        // TODO: shouldn't this be in Animation? \r\n        var canvas = animationProj.getCurrFrame();\r\n        canvas.setupNewLayer();\r\n    };\r\n    this.setKeyDown = function (doc) {\r\n        var toolbar = this;\r\n        var counterText = this.htmlCounter;\r\n        $(doc).keydown(function (e) {\r\n            var counterUpdateString = \"\";\r\n            switch (e.which) {\r\n                case 37: //left arrow key\r\n                    if (toolbar.down()) {\r\n                        var canvas = animationProj.getCurrFrame();\r\n                        counterUpdateString = \"frame: \" + (animationProj.currentFrame + 1) + \", layer: \" + (canvas.currentIndex + 1);\r\n                    }\r\n                    break;\r\n                case 39: //right arrow key\r\n                    if (toolbar.up()) {\r\n                        var canvas = animationProj.getCurrFrame();\r\n                        counterUpdateString = \"frame: \" + (animationProj.currentFrame + 1) + \", layer: \" + (canvas.currentIndex + 1);\r\n                    }\r\n                    break;\r\n                case 32: //space bar\r\n                    if (toolbar.layerMode) {\r\n                        toolbar.addPage();\r\n                    }\r\n                    else {\r\n                        animationProj.addNewFrame();\r\n                    }\r\n                    break;\r\n                case 65: // a key \r\n                    if (toolbar.prevFrame()) {\r\n                        var canvas = animationProj.getCurrFrame();\r\n                        counterUpdateString = \"frame: \" + (animationProj.currentFrame + 1) + \", layer: \" + (canvas.currentIndex + 1);\r\n                    }\r\n                    break;\r\n                case 68: // d key \r\n                    if (toolbar.nextFrame()) {\r\n                        var canvas = animationProj.getCurrFrame();\r\n                        counterUpdateString = \"frame: \" + (animationProj.currentFrame + 1) + \", layer: \" + (canvas.currentIndex + 1);\r\n                    }\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            if (toolbar.htmlCounter && counterUpdateString) {\r\n                counterText.textContent = counterUpdateString;\r\n            }\r\n            e.preventDefault();\r\n        });\r\n    };\r\n    /***\r\n        insert a frame after the current frame\r\n    ***/\r\n    this.insertLayer = function (elementId) {\r\n        // not sure if better idea to add the container the layers go in as an instance variable \r\n        // or pass in elementId here? \r\n        $('#' + elementId).click(function () {\r\n            var canvas = animationProj.getCurrFrame();\r\n            // add a new canvas first \r\n            canvas.setupNewLayer();\r\n            // then move it after the current canvas \r\n            var newestCanvas = canvas.canvasList.pop();\r\n            canvas.canvasList.splice(canvas.currentIndex + 1, 0, newestCanvas);\r\n        });\r\n    };\r\n    /***\r\n        delete current frame\r\n        shifts the current frame to the next one if there is one.\r\n        otherwise, the previous frame will become the current one.\r\n        if there isn't a previous one either, then the frame will just be made blank.\r\n    ***/\r\n    this.deleteLayer = function (elementId) {\r\n        // elementId here refers to the display that shows current frame and layer\r\n        var toolbarReference = this;\r\n        $('#' + elementId).click(function () {\r\n            var canvas = animationProj.getCurrFrame();\r\n            var oldCanvasIndex = canvas.currentIndex;\r\n            var oldCanvasId = canvas.currentCanvas.id;\r\n            var parentNode = document.getElementById(oldCanvasId).parentNode;\r\n            // if there's a canvas ahead of the current one \r\n            if (canvas.currentIndex + 1 < canvas.canvasList.length) {\r\n                // move current canvas to the next one \r\n                toolbarReference.up();\r\n                // remove the old canvas from the array and the DOM!\r\n                canvas.canvasList.splice(oldCanvasIndex, 1);\r\n                parentNode.removeChild(document.getElementById(oldCanvasId));\r\n                // adjust the current canvas index after the removal \r\n                canvas.currentIndex -= 1;\r\n            }\r\n            else if (canvas.currentIndex - 1 >= 0) {\r\n                // if there's a canvas behind the current one (and no more ahead)\r\n                // move current canvas to the previous one \r\n                // note that currentIndex doesn't need to be adjusted because removing the \r\n                // next canvas doesn't affect the current canvas' index\r\n                toolbarReference.down();\r\n                canvas.canvasList.splice(oldCanvasIndex, 1);\r\n                parentNode.removeChild(document.getElementById(oldCanvasId));\r\n                // but need to adjust the counter, if present\r\n                if (toolbarReference.htmlCounter) {\r\n                    toolbarReference.htmlCounter.textContent = \"frame: \" + (animationProj.currentFrame + 1) + \", layer:\" + (canvas.currentIndex + 1);\r\n                }\r\n            }\r\n            else {\r\n                // otherwise, just blank the canvas \r\n                var context = canvas.currentCanvas.getContext(\"2d\");\r\n                context.clearRect(0, 0, canvas.currentCanvas.getAttribute('width'), canvas.currentCanvas.getAttribute('height'));\r\n                context.fillStyle = \"#fff\";\r\n                context.fillRect(0, 0, canvas.currentCanvas.getAttribute('width'), canvas.currentCanvas.getAttribute('height'));\r\n            }\r\n        });\r\n    };\r\n    /***\r\n        add a new frame\r\n        note that it's adding a supercanvas instance\r\n    ***/\r\n    this.addNewFrameButton = function (elementId) {\r\n        $('#' + elementId).click(function () {\r\n            animationProj.addNewFrame();\r\n        });\r\n    };\r\n    /***\r\n        color wheel functions\r\n    ***/\r\n    // pass in the elementId of the div where the color wheel should be \r\n    // pass in the size of the canvas of the color wheel \r\n    this.createColorWheel = function (elementId, size) {\r\n        var location = document.getElementById(elementId);\r\n        var colorWheel = document.createElement('canvas');\r\n        colorWheel.id = \"colorWheel\";\r\n        colorWheel.setAttribute('width', size);\r\n        colorWheel.setAttribute('height', size);\r\n        var colorWheelContext = colorWheel.getContext('2d');\r\n        var x = colorWheel.width / 2;\r\n        var y = colorWheel.height / 2;\r\n        var radius = 90;\r\n        // why 5600??\r\n        for (var angle = 0; angle <= 5600; angle++) {\r\n            var startAngle = (angle - 2) * Math.PI / 180; //convert angles to radians\r\n            var endAngle = (angle) * Math.PI / 180;\r\n            colorWheelContext.beginPath();\r\n            colorWheelContext.moveTo(x, y);\r\n            //.arc(x, y, radius, startAngle, endAngle, anticlockwise)\r\n            colorWheelContext.arc(x, y, radius, startAngle, endAngle, false);\r\n            colorWheelContext.closePath();\r\n            //use .createRadialGradient to get a different color for each angle\r\n            //createRadialGradient(x0, y0, r0, x1, y1, r1)\r\n            var gradient = colorWheelContext.createRadialGradient(x, y, 0, startAngle, endAngle, radius);\r\n            gradient.addColorStop(0, 'hsla(' + angle + ', 10%, 100%, 1)');\r\n            gradient.addColorStop(1, 'hsla(' + angle + ', 100%, 50%, 1)');\r\n            colorWheelContext.fillStyle = gradient;\r\n            colorWheelContext.fill();\r\n        }\r\n        // make black a pickable color \r\n        colorWheelContext.fillStyle = \"#000\";\r\n        colorWheelContext.fillRect(0, 0, 8, 8);\r\n        // make white pickable too \r\n        colorWheelContext.fillRect(10, 0, 8, 8); // border around the white \r\n        colorWheelContext.fillStyle = \"#fff\";\r\n        colorWheelContext.fillRect(11, 0, 6, 7);\r\n        location.appendChild(colorWheel);\r\n        // make the color wheel interactive and show picked color \r\n        var showColor = document.createElement('p'); // this element will show the color picked \r\n        showColor.style.textAlign = 'center';\r\n        showColor.id = 'colorPicked';\r\n        showColor.textContent = \"pick a color! :)\";\r\n        location.appendChild(showColor);\r\n        $('#' + colorWheel.id).mousedown(function (e) {\r\n            var x = e.offsetX;\r\n            var y = e.offsetY;\r\n            var colorPicked = (document.getElementById(colorWheel.id).getContext('2d')).getImageData(x, y, 1, 1).data;\r\n            var colorPickedText = document.getElementById(showColor.id);\r\n            //correct the font color if the color is really dark\r\n            if (colorPicked[0] > 10 && colorPicked[1] > 200) {\r\n                $('#' + showColor.id).css(\"color\", \"#000\");\r\n            }\r\n            else {\r\n                $('#' + showColor.id).css(\"color\", \"#FFF\");\r\n            }\r\n            colorPickedText.textContent = 'rgb(' + colorPicked[0] + ',' + colorPicked[1] + ',' + colorPicked[2] + ')';\r\n            $('#' + showColor.id).css({ 'background-color': colorPickedText.textContent });\r\n            // update current color seleted in brush object as Uint8 clamped array where each index corresponds to r,g,b,a\r\n            brush.currColorArray = colorPicked;\r\n            brush.currColor = 'rgb(' + colorPicked[0] + ',' + colorPicked[1] + ',' + colorPicked[2] + ')';\r\n        });\r\n    };\r\n    /***\r\n    \r\n        attach floodfill function!\r\n    \r\n        still a bit slow. also, maybe instead of matching only exact color,\r\n        how about +/- 5 for r,g,b?\r\n        \r\n        also, maybe disable drawing? what if someone has the radial brush on\r\n        and they want to floodfill? it should operate normally in that case too.\r\n        might have to turn off the brush temporarily, then reconnect it?\r\n    \r\n    ***/\r\n    this.floodFill = function (elementId) {\r\n        $('#' + elementId).click(function () {\r\n            var canvas = animationProj.getCurrFrame();\r\n            var doFloodFill = function (e) {\r\n                // this is the color to change to!\r\n                // need to parse the currColor because right now it looks like \"rgb(x,y,z)\". \r\n                // I want it to look like [x, y, z]\r\n                var currColor = brush.currColor;\r\n                var currColorArray = currColor.substring(currColor.indexOf('(') + 1, currColor.length - 1).split(',');\r\n                currColorArray = currColorArray.map(function (a) { return parseInt(a); });\r\n                // get the coordinates of the selected pixel \r\n                var x = e.pageX - $('#' + canvas.currentCanvas.id).offset().left;\r\n                var y = e.pageY - $('#' + canvas.currentCanvas.id).offset().top;\r\n                //console.log(\"x: \" + x + \", y: \" + y);\r\n                var colorData = document.getElementById(canvas.currentCanvas.id).getContext(\"2d\").getImageData(x, y, 1, 1).data;\r\n                var color = 'rgb(' + colorData[0] + ',' + colorData[1] + ',' + colorData[2] + ')';\r\n                console.log(color);\r\n                // create an object with the pixel data\r\n                var pixel = { 'x': Math.floor(x), 'y': Math.floor(y), 'color': color };\r\n                // call the floodfill function!\r\n                // currentCanvas is a canvas element\r\n                floodfill(canvas.currentCanvas, currColorArray, pixel);\r\n                // remove event listener \r\n                canvas.currentCanvas.removeEventListener('click', doFloodFill);\r\n            };\r\n            canvas.currentCanvas.addEventListener('click', doFloodFill);\r\n        });\r\n    };\r\n    // the actual floodfill function \r\n    function floodfill(currentCanvas, newColor, pixelSelected) {\r\n        // create a stack \r\n        var stack = [];\r\n        // create visited set \r\n        // the format of these entries will be like: {'xCoord,yCoord': 1}\r\n        var visited = {};\r\n        // the selectedPixel will have the color that needs to be targeted by floodfill \r\n        var targetColor = pixelSelected.color;\r\n        // current canvas context \r\n        var ctx = document.getElementById(currentCanvas.id).getContext('2d');\r\n        // get the image data of the entire canvas \r\n        // do the floodfill, then put the edited image data back \r\n        var imageData = ctx.getImageData(0, 0, currentCanvas.width, currentCanvas.height);\r\n        var data = imageData.data;\r\n        stack.push(pixelSelected);\r\n        while (stack.length !== 0) {\r\n            // get a pixel\r\n            var currPixel = stack.pop();\r\n            // add to visited set \r\n            visited[currPixel.x + ',' + currPixel.y] = 1;\r\n            // get left, right, top and bottom neighbors \r\n            var leftNeighborX = currPixel.x - 1;\r\n            var rightNeighborX = currPixel.x + 1;\r\n            var topNeighborY = currPixel.y - 1;\r\n            var bottomNeighborY = currPixel.y + 1;\r\n            var r, g, b;\r\n            // top neighbor\r\n            if (topNeighborY >= 0 && visited[currPixel.x + ',' + topNeighborY] === undefined) {\r\n                // index of r, g and b colors in imageData.data\r\n                r = (topNeighborY * currentCanvas.width) * 4 + ((currPixel.x + 1) * 4);\r\n                g = r + 1;\r\n                b = g + 1;\r\n                if (targetColor === 'rgb(' + data[r] + ',' + data[g] + ',' + data[b] + ')') {\r\n                    // if the neighbor's color is the same as the targetColor, add it to the stack\r\n                    stack.push({ 'x': currPixel.x, 'y': topNeighborY, 'color': currPixel.color });\r\n                }\r\n            }\r\n            // right neighbor \r\n            if (rightNeighborX < currentCanvas.width && visited[rightNeighborX + ',' + currPixel.y] === undefined) {\r\n                r = (currPixel.y * currentCanvas.width) * 4 + ((rightNeighborX + 1) * 4);\r\n                g = r + 1;\r\n                b = g + 1;\r\n                if (targetColor === 'rgb(' + data[r] + ',' + data[g] + ',' + data[b] + ')') {\r\n                    // if the neighbor's color is the same as the targetColor, add it to the stack\r\n                    stack.push({ 'x': rightNeighborX, 'y': currPixel.y, 'color': currPixel.color });\r\n                }\r\n            }\r\n            // bottom neighbor\r\n            if (bottomNeighborY < currentCanvas.height && visited[currPixel.x + ',' + bottomNeighborY] === undefined) {\r\n                r = (bottomNeighborY * currentCanvas.width) * 4 + ((currPixel.x + 1) * 4);\r\n                g = r + 1;\r\n                b = g + 1;\r\n                if (targetColor === 'rgb(' + data[r] + ',' + data[g] + ',' + data[b] + ')') {\r\n                    // if the neighbor's color is the same as the targetColor, add it to the stack\r\n                    stack.push({ 'x': currPixel.x, 'y': bottomNeighborY, 'color': currPixel.color });\r\n                }\r\n            }\r\n            // left neighbor\r\n            if (leftNeighborX >= 0 && visited[leftNeighborX + ',' + currPixel.y] === undefined) {\r\n                r = (currPixel.y * currentCanvas.width) * 4 + ((leftNeighborX + 1) * 4);\r\n                g = r + 1;\r\n                b = g + 1;\r\n                if (targetColor === 'rgb(' + data[r] + ',' + data[g] + ',' + data[b] + ')') {\r\n                    // if the neighbor's color is the same as the targetColor, add it to the stack\r\n                    stack.push({ 'x': leftNeighborX, 'y': currPixel.y, 'color': currPixel.color });\r\n                }\r\n            }\r\n            // finally, update the color of the current pixel \r\n            r = (currPixel.y * currentCanvas.width) * 4 + ((currPixel.x + 1) * 4);\r\n            g = r + 1;\r\n            b = g + 1;\r\n            data[r] = newColor[0];\r\n            data[g] = newColor[1];\r\n            data[b] = newColor[2];\r\n        }\r\n        // put new edited image back on canvas \r\n        ctx.putImageData(imageData, 0, 0);\r\n    }\r\n    /***\r\n        rotate image\r\n        pass in an element id that will rotate the current canvas image on click\r\n        \r\n        currently buggy! after rotation, image becomes blurred. also, when attempting to draw on same canvas,\r\n        coordinates get altered so on mousedown the drawing gets offset\r\n    ***/\r\n    this.rotateImage = function (elementId) {\r\n        //rotate image\r\n        $('#' + elementId).click(function () {\r\n            var canvas = animationProj.getCurrFrame();\r\n            //using a promise to convert the initial image to a bitmap\r\n            var width = canvas.currentCanvas.getAttribute(\"width\");\r\n            var height = canvas.currentCanvas.getAttribute(\"height\");\r\n            var context = canvas.currentCanvas.getContext(\"2d\");\r\n            Promise.all([\r\n                createImageBitmap(canvas.currentCanvas, 0, 0, width, height)\r\n            ]).then(function (bitmap) {\r\n                context.clearRect(0, 0, width, height);\r\n                context.translate(width / 2, height / 2);\r\n                context.rotate((Math.PI) / 180);\r\n                context.translate(-width / 2, -height / 2);\r\n                //the returned bitmap is an array\r\n                context.drawImage(bitmap[0], 0, 0);\r\n            });\r\n        });\r\n    };\r\n    /***\r\n        clear the current canvas\r\n        pass in an element id that will execute clear canvas onclick\r\n    ***/\r\n    this.setClearCanvas = function (elementId) {\r\n        $('#' + elementId).click(function () {\r\n            var canvas = animationProj.getCurrFrame();\r\n            var context = canvas.currentCanvas.getContext(\"2d\");\r\n            context.clearRect(0, 0, canvas.currentCanvas.getAttribute('width'), canvas.currentCanvas.getAttribute('height'));\r\n            context.fillStyle = \"#FFFFFF\";\r\n            context.fillRect(0, 0, canvas.currentCanvas.getAttribute('width'), canvas.currentCanvas.getAttribute('height'));\r\n        });\r\n    };\r\n    /***\r\n        undo a previous drawing operation on the current canvas.\r\n        still a little incorrect?\r\n    ***/\r\n    this.undo = function (elementId) {\r\n        $('#' + elementId).click(function () {\r\n            var canvas = animationProj.getCurrFrame();\r\n            var context = canvas.currentCanvas.getContext(\"2d\");\r\n            var width = canvas.currentCanvas.getAttribute(\"width\");\r\n            var height = canvas.currentCanvas.getAttribute(\"height\");\r\n            // unshift to add to front of stack of snapshots. \r\n            brush.currentCanvasSnapshots.unshift(context.getImageData(0, 0, width, height));\r\n            // clear first\r\n            context.clearRect(0, 0, width, height);\r\n            // then put back last image (ignore the one that had just been drawn)\r\n            // snapshots is a temp variable that only holds all the images up to the 2nd to last image drawn. \r\n            // if you keep up to the last image drawn, then you have to click undo twice initially to get to the previous frame.\r\n            if (brush.currentCanvasSnapshots.length >= 1) {\r\n                var mostRecentImage = brush.currentCanvasSnapshots.pop();\r\n                context.putImageData(mostRecentImage, 0, 0);\r\n            }\r\n        });\r\n    };\r\n    /***\r\n        import an image\r\n    ***/\r\n    this.importImage = function (elementId) {\r\n        $('#' + elementId).click(function () {\r\n            var canvas = animationProj.getCurrFrame();\r\n            // call fileHandler here\r\n            fileHandler();\r\n            // define fileHandler \r\n            function fileHandler() {\r\n                //initiate file choosing after button click\r\n                var input = document.createElement('input');\r\n                input.type = 'file';\r\n                input.addEventListener('change', getFile, false);\r\n                input.click();\r\n            }\r\n            function getFile(e) {\r\n                var img = new Image();\r\n                var reader = new FileReader();\r\n                var file = e.target.files[0];\r\n                if (!file.type.match(/image.*/)) {\r\n                    console.log(\"not a valid image\");\r\n                    return;\r\n                }\r\n                //when the image loads, put it on the canvas.\r\n                img.onload = function () {\r\n                    // change current canvas' width and height according to imported picture\r\n                    // to keep proportion \r\n                    // i.e. if width is at least 100px more than height, scale the current canvas'\r\n                    // height back by multiplying .9 to 800. \r\n                    var currentCanvas = canvas.currentCanvas;\r\n                    var context = currentCanvas.getContext(\"2d\");\r\n                    var height = img.height;\r\n                    var width = img.width;\r\n                    if ((img.width - img.height) >= 100) {\r\n                        // if image is wider than it is tall\r\n                        currentCanvas.setAttribute('height', Math.floor(800 * .9));\r\n                        currentCanvas.setAttribute('width', Math.floor(800 * 1.1));\r\n                        height = currentCanvas.height;\r\n                        width = currentCanvas.width;\r\n                    }\r\n                    else if ((img.height - img.width) >= 200) {\r\n                        // if image is taller than it is wide\r\n                        currentCanvas.setAttribute('width', Math.floor(800 * .9));\r\n                        currentCanvas.setAttribute('height', Math.floor(800 * 1.1));\r\n                        height = currentCanvas.height;\r\n                        width = currentCanvas.width;\r\n                    }\r\n                    else {\r\n                        // default value in super canvas object\r\n                        height = canvas.height;\r\n                        width = canvas.width;\r\n                        currentCanvas.setAttribute('height', height);\r\n                        currentCanvas.setAttribute('width', width);\r\n                    }\r\n                    context.drawImage(img, 0, 0, width, height);\r\n                    // assign recentImage variable the image \r\n                    recentImage = img;\r\n                    // add the current image to snapshots \r\n                    brush.currentCanvasSnapshots.push(context.getImageData(0, 0, width, height));\r\n                };\r\n                //after reader has loaded file, put the data in the image object.\r\n                reader.onloadend = function () {\r\n                    img.src = reader.result;\r\n                };\r\n                //read the file as a URL\r\n                reader.readAsDataURL(file);\r\n            }\r\n        });\r\n    };\r\n    /***\r\n        reset the canvas to most recent imported image\r\n    ***/\r\n    this.resetImage = function () {\r\n        if (recentImage) {\r\n            var canvas = animationProj.getCurrFrame();\r\n            var context = canvas.currentCanvas.getContext(\"2d\");\r\n            var height = canvas.currentCanvas.getAttribute(\"height\");\r\n            var width = canvas.currentCanvas.getAttribute(\"width\");\r\n            context.drawImage(recentImage, 0, 0, width, height);\r\n        }\r\n    };\r\n    /***\r\n        download a png file of the current canvas\r\n    ***/\r\n    this.download = function (elementId) {\r\n        $('#' + elementId).click(function () {\r\n            // get image data from current canvas as blob\r\n            var data = document.getElementById(canvas.currentCanvas.id).toBlob(function (blob) {\r\n                var url = URL.createObjectURL(blob);\r\n                var link = document.createElement('a');\r\n                link.href = url;\r\n                var name = prompt(\"please enter a name for the file\");\r\n                if (name === null) {\r\n                    return;\r\n                }\r\n                else {\r\n                    link.download = name;\r\n                    //simulate a click on the blob's url to download it \r\n                    link.click();\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /********\r\n    \r\n        this section controls the animation playback features\r\n        \r\n        note that I specifically added my page counter element to the\r\n        functions so that they change with the call to up() and down()\r\n\r\n        this will need to be applied for FRAMES, not LAYERS of a frame.\r\n    \r\n    *********/\r\n    var toolbar = this;\r\n    var playFor = function () {\r\n        if (toolbar.nextFrame()) {\r\n            if (toolbar.htmlCounter) {\r\n                var counterText = toolbar.htmlCounter;\r\n                counterText.textContent = \"frame: \" + (animationProj.currentFrame + 1) + \", layer: \" + (canvas.currentIndex + 1);\r\n            }\r\n        }\r\n    };\r\n    var playBack = function () {\r\n        if (toolbar.prevFrame()) {\r\n            if (toolbar.htmlCounter) {\r\n                var counterText = toolbar.htmlCounter;\r\n                counterText.textContent = \"frame: \" + (animationProj.currentFrame + 1) + \", layer: \" + (canvas.currentIndex + 1);\r\n            }\r\n        }\r\n    };\r\n    this.playForward = function () {\r\n        clearInterval(play);\r\n        play = null;\r\n        play = setInterval(playFor, this.timePerFrame);\r\n    };\r\n    this.playBackward = function () {\r\n        clearInterval(play);\r\n        play = null;\r\n        //canvas.currentCanvas = canvas.canvasList[canvas.canvasList.length - 1];\r\n        //canvas.currentCanvas.style.zIndex = 1;\r\n        //canvas.currentCanvas.style.opacity = .97;\r\n        play = setInterval(playBack, this.timePerFrame);\r\n    };\r\n    this.stop = function () {\r\n        clearInterval(play);\r\n        play = null;\r\n    };\r\n    /***\r\n    \r\n        create a gif from the frames.\r\n        using gif.js - https://github.com/jnordberg/gif.js\r\n    \r\n        elementId is for the loading message,\r\n        i.e. a <p> element that says \"now loading...\"\r\n        \r\n        this will need to be applied for FRAMES, not LAYERS of a frame.\r\n    \r\n    ***/\r\n    this.getGif = function (elementId) {\r\n        if (elementId) {\r\n            document.getElementById(elementId).textContent = \"now loading...\";\r\n        }\r\n        var gif = new GIF({\r\n            workers: 2,\r\n            quality: 10\r\n        });\r\n        // add frames\t\t\r\n        for (var i = 0; i < animationProj.frameList.length; i++) {\r\n            var tempCanvas = document.createElement('canvas');\r\n            tempCanvas.width = 800; // don't hardcode dimensions :<\r\n            tempCanvas.height = 800;\r\n            var tempCtx = tempCanvas.getContext(\"2d\");\r\n            tempCtx.fillStyle = \"white\";\r\n            tempCtx.fillRect(0, 0, 800, 800);\r\n            var tempImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);\r\n            var currFrame = animationProj.frameList[i];\r\n            for (var j = 0; j < currFrame.canvasList.length; j++) {\r\n                var layer = currFrame.canvasList[j];\r\n                var imageData = layer.getContext(\"2d\").getImageData(0, 0, layer.width, layer.height).data;\r\n                for (var k = 0; k < imageData.length; k += 4) {\r\n                    if (imageData[k] === 255 && imageData[k + 1] === 255 && imageData[k + 2] === 255) {\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        // what if the canvas we're getting image data from to draw on the onion skin is LARGER than the onion skin canvas.\r\n                        // we might run into index/length issues...\r\n                        tempImageData.data[k] = imageData[k];\r\n                        tempImageData.data[k + 1] = imageData[k + 1];\r\n                        tempImageData.data[k + 2] = imageData[k + 2];\r\n                        tempImageData.data[k + 3] = 255;\r\n                    }\r\n                }\r\n                // apply each layer to the onion skin\r\n                tempCtx.putImageData(tempImageData, 0, 0);\r\n            }\r\n            // TODO: make sure to merge all the layers for each frame!\r\n            gif.addFrame(tempCanvas, { delay: this.timePerFrame });\r\n        }\r\n        gif.on('finished', function (blob) {\r\n            document.getElementById(elementId).textContent = \"\";\r\n            var newGif = URL.createObjectURL(blob);\r\n            window.open(newGif);\r\n        });\r\n        gif.render();\r\n    };\r\n    /***\r\n    \r\n        save/export & import functions\r\n        check this out: https://stackoverflow.com/questions/22329481/compressing-base64-data-uri-images\r\n        \r\n        don't think this is going to work without some sort of better compression. simply drawing a few lines on\r\n        a canvas produces a very large base64 string spanning many lines. not very practical for exporting a project\r\n        that has several frames, especially if you take into account different colors and more detail\r\n        \r\n    ***/\r\n    this.save = function (elementId) {\r\n        $('#' + elementId).click(function () {\r\n            // prompt the user to name the file \r\n            var name = prompt(\"name of file: \");\r\n            if (name === \"\") {\r\n                name = \"funSketch_saveFile\";\r\n            }\r\n            else if (name === null) {\r\n                return;\r\n            }\r\n            var savedData = [];\r\n            animationProj.frameList.forEach(function (frame) {\r\n                // get frame metadata\r\n                var newFrame = frame.getMetadata();\r\n                newFrame['layers'] = []; // list of objects\r\n                frame.canvasList.forEach(function (layer) {\r\n                    // get layer metadata\r\n                    var newLayer = {\r\n                        'id': layer.id,\r\n                        'width': layer.getAttribute(\"height\"),\r\n                        'height': layer.getAttribute(\"width\"),\r\n                        'zIndex': layer.style.zIndex,\r\n                        'opacity': layer.style.opacity,\r\n                    };\r\n                    // add layer image data\r\n                    newLayer['imageData'] = layer.toDataURL();\r\n                    newFrame.layers.push(newLayer);\r\n                });\r\n                savedData.push(JSON.stringify(newFrame));\r\n            });\r\n            var json = \"[\\n\";\r\n            json += savedData.join(\",\\n\"); // put a line break between each new object, which represents a frame\r\n            json += \"\\n]\";\r\n            // make a blob so it can be downloaded \r\n            var blob = new Blob([json], { type: \"application/json\" });\r\n            var url = URL.createObjectURL(blob);\r\n            var link = document.createElement('a');\r\n            link.href = url;\r\n            link.download = name + \".json\";\r\n            link.click();\r\n        });\r\n    };\r\n    this.importProject = function (elementId, counterId) {\r\n        var self = this;\r\n        $('#' + elementId).click(function () {\r\n            fileHandler();\r\n            //import project json file\r\n            function fileHandler() {\r\n                var input = document.createElement('input');\r\n                input.type = 'file';\r\n                input.addEventListener('change', getFile, false);\r\n                input.click();\r\n            }\r\n            function getFile(e) {\r\n                var reader = new FileReader();\r\n                var file = e.target.files[0];\r\n                //when the file loads, put it on the canvas.\r\n                reader.onload = (function (theFile) {\r\n                    return function (e) {\r\n                        // parse the JSON using JSON.parse \r\n                        // check if it can be parsed though first!\r\n                        var data;\r\n                        try {\r\n                            data = JSON.parse(e.target.result);\r\n                        }\r\n                        catch (e) {\r\n                            // not valid json file \r\n                            return;\r\n                        }\r\n                        // do some validation\r\n                        // if there is no canvas\r\n                        // or it's a valid json object but no fields correspond to a canvas, quit\r\n                        if (!data[0] || (!data[0].name && !data[0].height && !data[0].width && !data[0].data)) {\r\n                            console.log(\"it appears to not be a valid project! :<\");\r\n                            return;\r\n                        }\r\n                        // clear existing project\r\n                        animationProj.resetProject();\r\n                        // update UI \r\n                        if (self.htmlCounter) {\r\n                            // ideally if you use react or some library that can update the view based on the current state,\r\n                            // you shouldn't need this at all. hint hint.\r\n                            self.htmlCounter.textContent = \"frame: \" + (animationProj.currentFrame + 1) + \", layer: \" + (canvas.currentIndex + 1);\r\n                        }\r\n                        // load saved project\r\n                        data.forEach(function (frame, index) {\r\n                            if (index > 0) {\r\n                                // add a new frame\r\n                                animationProj.addNewFrame();\r\n                            }\r\n                            // overwrite existing frame\r\n                            // TODO: implement an updateFrame method \r\n                            // animationProj.updateFrame(0, frame); // updateFrame takes an index of the existing frame to overwrite and takes a SuperCanvas object to update with as well\r\n                            var currFrame = animationProj.frameList[index];\r\n                            console.log(\"need to add \" + frame.layers.length + \" layers for frame: \" + (index + 1));\r\n                            var currFrameLayersFromImport = frame.layers; // looking at data-to-import's curr frame's layers\r\n                            var currFrameLayersFromCurrPrj = currFrame.canvasList;\r\n                            currFrameLayersFromImport.forEach(function (layer, layerIndex) {\r\n                                if ((layerIndex + 1) > currFrameLayersFromCurrPrj.length) {\r\n                                    // add new layer to curr project as needed based on import\r\n                                    console.log(\"need to add a new layer for frame: \" + index);\r\n                                    animationProj.frameList[index].setupNewLayer();\r\n                                }\r\n                                var currLayer = animationProj.frameList[index].canvasList[layerIndex];\r\n                                // is this part necessary? maybe, if you want the project to look exactly as when it was saved.\r\n                                currLayer.style.opacity = layer.opacity;\r\n                                currLayer.style.zIndex = layer.zIndex;\r\n                                currLayer.height = layer.height;\r\n                                currLayer.width = layer.width;\r\n                                // add the image data \r\n                                var newCtx = currLayer.getContext(\"2d\");\r\n                                var img = new Image();\r\n                                (function (context, image) {\r\n                                    image.onload = function () {\r\n                                        context.drawImage(image, 0, 0);\r\n                                    };\r\n                                    image.src = layer.imageData;\r\n                                })(newCtx, img);\r\n                            });\r\n                        });\r\n                    };\r\n                })(file);\r\n                reader.readAsText(file);\r\n            }\r\n        });\r\n    };\r\n} // end of Toolbar \r\n\r\n\r\nexport {\r\n\tToolbar\r\n};"],"sourceRoot":""}