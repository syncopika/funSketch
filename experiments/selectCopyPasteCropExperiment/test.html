<!doctype html>

<html>

<head>
	<title> select/copy/paste/crop experiment </title>
	<style>
		body {
			text-align: center;
		}
		#main {
			border: 1px solid #000;
		}
		#canvasArea{
			position: relative;
			margin: 0px auto;
			width: 800px;
			height: 500px;
		}
		#editCanvas{
			cursor: crosshair;
		}
	</style>
</head>

<body>
	<h2> select/copy/paste/crop experiment </h2>
	
	<div>
		<button id="select">select</button>
		<button id="importImage">import image</button>
	</div>
	
	<br />

	<div id='canvasArea'>
	</div>
<body>


<script>
document.getElementById("importImage").addEventListener('click', () => {
	const canvas = document.getElementById("main");
	
	// call fileHandler here
	fileHandler();
	
	// define fileHandler 
	function fileHandler(){
		//initiate file choosing after button click
		let input = document.createElement('input');
		input.type = 'file';
		input.addEventListener('change', getFile, false);
		input.click();
	}
	
	function getFile(e){
		const img = new Image();
		const reader = new FileReader();
		const file = e.target.files[0];
		if(!file.type.match(/image.*/)){
			console.log("not a valid image");
			return;
		}
		//when the image loads, put it on the canvas.
		img.onload = () => {
			// change current canvas' width and height according to imported picture
			const currentCanvas = canvas.currentCanvas;
			const context = canvas.getContext("2d");
			const height = canvas.height;
			const width = canvas.width;
			
			context.drawImage(img, 0, 0, width, height);
		};
		//after reader has loaded file, put the data in the image object.
		reader.onloadend = function(){ 
			img.src = reader.result;
		};
		//read the file as a URL
		reader.readAsDataURL(file);
	}
});


function setUpMainCanvas(){
	const canvasElement = document.createElement("canvas");
	document.getElementById("canvasArea").appendChild(canvasElement);
	canvasElement.id = "main";
	//canvasElement.style.position = "absolute";
    canvasElement.style.border = '1px #000 solid';
    canvasElement.style.zIndex = 1;
    canvasElement.style.opacity = 1;
	canvasElement.style.width = "100%";
	canvasElement.style.height = "100%";
	canvasElement.width = canvasElement.offsetWidth;
	canvasElement.height = canvasElement.offsetHeight;
    canvasElement.getContext("2d").fillStyle = "rgba(255, 255, 255, 1)";
    canvasElement.getContext("2d").fillRect(0, 0, canvasElement.width, canvasElement.height);
}
setUpMainCanvas();

function setUpEditCanvas(){
	const canvasElement = document.createElement("canvas");
	document.getElementById("canvasArea").appendChild(canvasElement);
	canvasElement.id = "editCanvas";
	canvasElement.style.position = "absolute";
    canvasElement.style.border = '1px #000 solid';
    canvasElement.style.zIndex = 10;
	canvasElement.style.width = "100%";
	canvasElement.style.height = "100%";
	canvasElement.style.top = 0;
	canvasElement.style.left = 0;
	canvasElement.width = canvasElement.offsetWidth;
	canvasElement.height = canvasElement.offsetHeight;
    canvasElement.getContext("2d").fillStyle = "rgba(255,255,255,0.1)";
    canvasElement.getContext("2d").fillRect(0, 0, canvasElement.width, canvasElement.height);
	return canvasElement;
}

// select functionality
const selectData = {
	clickX: [],
	clickY: [],
	
	// this is for when moving the selection
	mousedown: [],
	//mouseup: [],
};
let isSelect = false;
let isMousedown = false;
let doneSelectMove = false;
let editCanvas;

function selectMousemove(evt){
	if(isMousedown){
		
		/* attempted strategy to deal with a gap in logged coordinates but introduces lag and messes up drawing for selection :/
		if(selectData.clickX.length > 1){
			let lastY = selectData.clickY[selectData.clickY.length-2];
			let lastX = selectData.clickX[selectData.clickX.length-2];
			if(evt.offsetY > lastY+1){
				// fill in any coordinates in between this one and the previous (based on y-value)
				// so we can always have a pair of coordinates for the same row if it's passed through twice
				// this ensures a record of a continuous line
				// but we also need to consider how x changes from the prev to curr coord.
				const xInterval = Math.floor( (evt.offsetX - lastX) / (evt.offsetY - lastY) );
				for(let i = lastY+1; i < evt.offsetY; i++){
					selectData.clickX.push(lastX + xInterval);
					selectData.clickY.push(i);
					lastX += xInterval;
				}
			}
		}
		*/
		
		selectData.clickX.push(evt.offsetX);
		selectData.clickY.push(evt.offsetY);
	
		const ctx = document.getElementById('editCanvas').getContext('2d');
		
		// use the inverted color of the pixel of the main context
		const srcCtx = document.getElementById('main').getContext('2d');
		const data = srcCtx.getImageData(evt.offsetX, evt.offsetY, 1, 1).data;
		const color = `rgb(${255-data[0]}, ${255-data[1]}, ${255-data[2]})`;
		
		ctx.strokeStyle = color;
		ctx.lineWidth = 3;
		ctx.beginPath();
		
		if(selectData.clickX.length-2 >= 0){
			ctx.moveTo(selectData.clickX[selectData.clickX.length-2], selectData.clickY[selectData.clickY.length-2]);
		}else{
			ctx.moveTo(selectData.clickX[selectData.clickX.length-1], selectData.clickY[selectData.clickY.length-1]);
		}
		
		ctx.lineTo(selectData.clickX[selectData.clickX.length-1], selectData.clickY[selectData.clickY.length-1]);
		
		ctx.closePath();
		ctx.stroke();
	}
}

function selectMousedown(evt){
	isMousedown = true;
	selectData.clickX = [evt.offsetX];
	selectData.clickY = [evt.offsetY];
}

function selectMouseup(evt){
	isMousedown = false;

	// allow user to do something with the selection
	editCanvas.removeEventListener('mousedown', selectMousedown);
	editCanvas.removeEventListener('mousemove', selectMousemove);
	editCanvas.removeEventListener('mouseup', selectMouseup);
	
	// add the new event listeners to handle moving the selection
	// interesting: https://stackoverflow.com/questions/12886286/addeventlistener-for-keydown-on-canvas
	document.addEventListener('keydown', deleteSelectedPixels);
}

function selectMoveMousedown(evt){
	// record the coordinate clicked so we can subtract from the coords of mouseup to create a vector
	// so we know how much to move the selected pixels left/right and up/down.
	isMousedown = true;
	selectData.mousedown = [evt.offsetX, evt.offsetY];
}

function selectMoveMousemove(evt){
	// record current coordinate of mouse to create vector from mousedown coordinate to know how to move selected pixels
	if(isMousedown){
		const lastX = selectData.mousedown[0];
		const lastY = selectData.mousedown[1];
		
		const currX = evt.offsetX;
		const currY = evt.offsetY;
		
		// get a copy of the selected pixels
		
		// remove pixels from src
		removePixels(selectData);
		
		// move selected pixels on edit canvas
		
		// update mousedown coords
		selectData.mousedown = [evt.offsetX, ect.offsetY];
	}
}

function selectMoveMouseup(evt){
	isMousedown = false;
	selectData.mousedown = [];
}

function deleteSelectedPixels(evt){
	if(evt.which === 46 && isSelect){
		// 46 is the delete button. can also use evt.code which would be "Delete"
		
		// remove selected pixels
		removePixels(selectData);
		
		// remove edit canvas
		editCanvas.parentNode.removeChild(editCanvas);
		
		isSelect = false;	
	}
}

function removePixels(pixelCoordData){
	// given x and y coords of each point on a line, figure out what pixels make up the area surrounded by the line
	// and change them to #fff
	// what if it's a straight line? just connect the first and last points to create an enclosed area like MS Paint?
	const coords = {};
	for(let i = 0; i < pixelCoordData.clickY.length; i++){
		const currY = pixelCoordData.clickY[i];
		const currX = pixelCoordData.clickX[i];
		if(!coords[currY]){
			coords[currY] = {
				maxX: currX,
				minX: currX,
			}
		}else{
			if(currX > coords[currY].maxX){
				coords[currY].maxX = currX;
			}else if(currX < coords[currY].minX){
				coords[currY].minX = currX;
			}
		}
	}
	//console.log(coords);
	
	// then change the colors of the pixels that fall in range of minX and maxX of each y-coord in coords
	const src = document.getElementById("main");
	const srcCtx = src.getContext('2d');
	const imgData = srcCtx.getImageData(0,0,src.width,src.height);
	for(let row in coords){
		const min = coords[row].minX;
		const max = coords[row].maxX;
		const start = src.width*4*row + 4*min;
		const end = src.width*4*row + 4*max;
		for(let i = start; i < end; i += 4){
			imgData.data[i] = 255;
			imgData.data[i+1] = 255;
			imgData.data[i+2] = 255;
		}
	}
	
	srcCtx.putImageData(imgData, 0, 0);
}

document.getElementById("select").addEventListener('click', () => {
	if(!isSelect){
		isSelect = true;
	
		// create new invisible canvas on top of current to keep track of crop area
		editCanvas = setUpEditCanvas();
		
		// attach event listener for mousedown/mouseup when cropping
		editCanvas.addEventListener('mousedown', selectMousedown);
		editCanvas.addEventListener('mousemove', selectMousemove);
		editCanvas.addEventListener('mouseup', selectMouseup);
	}
});


</script>



</html>